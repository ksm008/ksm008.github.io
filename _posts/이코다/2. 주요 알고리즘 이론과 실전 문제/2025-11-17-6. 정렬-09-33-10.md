---
layout: post
title: 6. 정렬
date: 2025-11-17 09:33:10 +0900
categories:
  - 이코다
published: true
math: true
tags:
  - 이코다
---
## 1. 기준에 따라 데이터를 정렬
### 정렬 알고리즘 개요
정렬은 데이터를 특정한 기분에 따라서 순서대로 나열하는 것. 정렬을 하고 나면 이진 탐색이 가능해짐. 고로 정렬은 이진 탐색의 전처리 과정과 같으니 제대로 알고 넘어가야 한다. 책에서 다루는 정렬 알고리즘은 다음과 같다.
- 선택 정렬
- 삽입 정렬
- 퀵 정렬
- 계수 정렬

### 선택 정렬
가장 작은 값을 첫 번째로 보내고, 그 다음으로 작은 값을 두 번째로 보내는 정렬 방식이다. 
선택 정렬은 보통 데이터의 개수가 1만개를 넘어가기 시작하면 정렬 속도가 급격히 느려진다. 비효율적인 알고리즘이긴 하나, 코딩 테스트에서 가장 작은 데이터를 찾는 일이 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요가 있다. 

```java
import java.io.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int[] array = new int[]{7,5,9,0,3,1,6,2,4,8};  
  
        for (int i = 0; i < array.length; i++) {  
            int minIdx = i;  
            int temp = 0;  
            for (int j = i + 1; j < array.length; j++) {  
                if (array[j] < array[minIdx]) {  
                    minIdx = j;  
                }  
            }  
            temp = array[i];  
            array[i] = array[minIdx];  
            array[minIdx] = temp;  
        }  
  
        for (int i = 0; i < array.length; i++) {  
            sb.append(array[i] + " ");  
        }  
          
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

선택 정렬은 N - 1번만큼 가장 작은 수를 찾아 가장 앞으로 보내야 하는데, 매번 작은 수를 찾기 위한 연산이 또 필요하다. 이를 빅오 표기법으로 단순하게 표현하면 O(N^2)가 된다. 이러한 시간 복잡도를 가지게 될 경우, 데이터의 개수가 늘어날 수록 시간은 급격히 느려진다. 

### 삽입 정렬
데이터를 확인하며 적절한 위치에 삽입하는 알고리즘. 여기서 특정한 데이터가 적절한 위치에 들어가기 전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.

```java
import java.io.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int[] array = new int[]{7,5,9,0,3,1,6,2,4,8};  
  
        for (int i = 1; i < array.length; i++) {  
            int temp;  
            for (int j = i; j > 0; j--) {  
                if (array[j] < array[j - 1]) {  
                    temp = array[j];  
                    array[j] = array[j - 1];  
                    array[j - 1] = temp;  
                } else break;  
            }  
        }  
  
        for (int i = 0; i < array.length; i++) {  
            sb.append(array[i] + " ");  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```
### 퀵 정렬
가장 많이 사용되는 정렬 알고리즘이다. 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다.

기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 알고리즘이다. 따라서 이 정렬에서는 그 기준이 되는 '피벗'을 설정한다. 

여기서 또 피벗을 설정한 후 리스트를 분할하는 방법에 따라 여러가지 방식으로 퀵 정렬을 구분한다. 처음에는 가장 대표적인 방식인 호어 분할 방식을 기준으로 퀵 정렬을 설명한다. 호어 분할 방식은 다음과 같은 규칙에 따라서 피벗을 설정한다.
- 리스트의 첫 번째 데이터를 피벗으로 설정한다.
