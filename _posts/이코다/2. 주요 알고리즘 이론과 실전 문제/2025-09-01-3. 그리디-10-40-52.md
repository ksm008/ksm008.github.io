---
layout: post
title: 3. 그리디
date: 2025-09-01 10:40:52 +0900
categories:
  - 이코다
  - 2. 주요 알고리즘 이론과 실전 문제
published: true
tags:
  - 이코다
---
## 1. 당장 좋은 것만 선택하는 그리디
현재 상황에서 지금 당장 좋은 것만 고르는 방법이다. 매 순간마다 가장 좋아보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다. 

그리디 알고리즘의 문제 유형은 이후 나오는 알고리즘과 비교했을때 '사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형' 이라는 특징이 있다. 반면 다른 알고리즘들인 정렬, 최단 경로 등의 알고리즘 유형은 그 사용 방법을 정확히 알고 있어야만 해결이 가능한 경우가 많다.

정렬의 경우 정렬 라이브러리의 사용 방법을 알고 있어야 하며 최단 경로를 빠르게 찾는 문제는 플로이드 워셜 혹은 다익스트라 알고리즘과 같은 특정 알고리즘을 미리 알고 있거나 팀 노트를 통해 준비해풀 수 있다 (다익스트라의 경우 그리디 알고리즘임녀서도 암기가 필요하다) 뭐, 아무튼...

그리디 알고리즘 문제의 유형은 매우 다양하기 때문에 암기한다고 해서 항상 잘 풀 수 있다고 보장할 순 없다. 떄문에 많은 유형을 접하고 문제를 풀어보며 훈련해야한다.

코테에 출제되는 그리디 알고리즘 유형 문제들은 창의력을 요구한다. 문제를 풀기위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하기 때문에 현재 상황에서 가장 좋아보이는 것만 선택해도 문제를 풀 수 있는지 파악할 수 있어야 한다.

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로' 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 주로 정렬과 그디리는 짝을 이뤄 출제된다.

가장 대표적인 문제는 거스름돈 문제가 있다.

### 예제 3.1. 거스름돈

거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무수히 존재한다고 가정했을때, 손님에게 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 언제나 10의 배수이다.

적은 개수의 동전을 쓰는 방법은 바로 금액이 큰 동전부터 거슬러 주는 것이다. 맨 처음에 500원으로 최대한 금액을 맞추고 이후에는 100, 50, 10원 순으로 금액을 맞추어 돌려주면 된다.

```java
import java.io.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
    public static void main(String[] args) throws IOException {  
  
        int num = Integer.parseInt(br.readLine());  
        int count = 0;  
  
        int[] coins_type = {500, 100, 50, 10};  
  
        for (int coin : coins_type) {  
            count += num / coin;  
            num %= coin;  
        }  
  
        bw.write(count + "");  
  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

입력 값을 1260이라고 가정했을 경우, 아래와 같이 진행된다.

1. 500으로 나눈 몫을 count에 더한다. 1260 / 500 = 2이므로 2가 count에 더해진다.
2. num값을 500으로 나눈 나머지 값으로 바꾼다. 1260 % 500 이므로 260이 된다.
3. 그 다음은 100을 나눈 몫인 2를 count에 더하고, 다시 나머지 값으로 바꾸면 60.
4. 다음은 50으로 나눈 몫인 1을 count에 더하고, 다시 나머지 값으로 바꾸면 10.
5. 마지막으로 10으로 나눈 몫인 1을 count에 더한다.

이렇게 최소한의 동전 개수는 6개임을 알 수 있다.


화폐의 종류가 K개라고 했을때 코드의 시간 복잡도는 O(K)이다. 즉 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고 거슬러 줘야 하는 금액의 크기와는 무관하다.

### 그리디 알고리즘의 정당성

모든 문제에 그리디 알고리즘을 적용하는 것은 아니다. 대부분의 문제의 경우 그리디 알고리즘을 사용했을 때 최적의 해를 찾을 수 없을 가능성이 다분. 

그리디 알고리즘으로 해법을 찾았다면 그 해법이 정당한지 검토해야 한다. 거스름돈 문제의 경우 돌려줄 동전의 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전을 종합하여 다른 해가 나올 수 없기 때문에 그리디 알고리즘으로 해결이 가능했다. 만약 거슬러줘야 하는 돈은 800원, 화폐 단위가 500, 400, 100원일 경우 그리디 알고리즘으로는 500 + 100 + 100 + 100 = 4개의 동전을 거슬러줘야 한다. 하지만 최적의 해는 400 + 400 이므로 2개의 동전이다. 

따라서 그리디 알고리즘의 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

만약 문제 유형을 바로 파악할 수 없다면 그리디 알고리즘을 먼저 의심해보고 탐욕적인 해결법이 존재하는지 고민해보다. 만약 찾을 수 없다면 이후에 배울 다이나믹 프로그래밍이나 그래프 알고리즘 등을 사용하여 해결할 수 있는지 고민해보는 것도 방법이다.

만약 화폐의 단위가 무작위로 주어졌을 경우 그리디로는 해결을 할 수 없다. 이후 다이나믹 프로그래밍으로 해결할 수 있고 해당 문제도 추후 나올 예정이다.

## 실전 문제 - 큰 수의 법칙

동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과할 수 없는 것이 이 법칙의 특징이다.

서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
