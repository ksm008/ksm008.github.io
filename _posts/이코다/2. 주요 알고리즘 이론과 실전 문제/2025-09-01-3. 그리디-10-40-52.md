---
layout: post
title: 3. 그리디
date: 2025-09-01 10:40:52 +0900
categories:
  - 이코다
  - 2. 주요 알고리즘 이론과 실전 문제
published: true
tags:
  - 이코다
---
## 1. 당장 좋은 것만 선택하는 그리디
현재 상황에서 지금 당장 좋은 것만 고르는 방법이다. 매 순간마다 가장 좋아보이는 것을 선택하며 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다. 

그리디 알고리즘의 문제 유형은 이후 나오는 알고리즘과 비교했을때 '사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형' 이라는 특징이 있다. 반면 다른 알고리즘들인 정렬, 최단 경로 등의 알고리즘 유형은 그 사용 방법을 정확히 알고 있어야만 해결이 가능한 경우가 많다.

정렬의 경우 정렬 라이브러리의 사용 방법을 알고 있어야 하며 최단 경로를 빠르게 찾는 문제는 플로이드 워셜 혹은 다익스트라 알고리즘과 같은 특정 알고리즘을 미리 알고 있거나 팀 노트를 통해 준비해풀 수 있다 (다익스트라의 경우 그리디 알고리즘임녀서도 암기가 필요하다) 뭐, 아무튼...

그리디 알고리즘 문제의 유형은 매우 다양하기 때문에 암기한다고 해서 항상 잘 풀 수 있다고 보장할 순 없다. 떄문에 많은 유형을 접하고 문제를 풀어보며 훈련해야한다.

코테에 출제되는 그리디 알고리즘 유형 문제들은 창의력을 요구한다. 문제를 풀기위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하기 때문에 현재 상황에서 가장 좋아보이는 것만 선택해도 문제를 풀 수 있는지 파악할 수 있어야 한다.

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로' 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 주로 정렬과 그디리는 짝을 이뤄 출제된다.

가장 대표적인 문제는 거스름돈 문제가 있다.

### 예제 3.1. 거스름돈

거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무수히 존재한다고 가정했을때, 손님에게 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 언제나 10의 배수이다.

적은 개수의 동전을 쓰는 방법은 바로 금액이 큰 동전부터 거슬러 주는 것이다. 맨 처음에 500원으로 최대한 금액을 맞추고 이후에는 100, 50, 10원 순으로 금액을 맞추어 돌려주면 된다.

```java
import java.io.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
    public static void main(String[] args) throws IOException {  
  
        int num = Integer.parseInt(br.readLine());  
        int count = 0;  
  
        int[] coins_type = {500, 100, 50, 10};  
  
        for (int coin : coins_type) {  
            count += num / coin;  
            num %= coin;  
        }  
  
        bw.write(count + "");  
  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

입력 값을 1260이라고 가정했을 경우, 아래와 같이 진행된다.

1. 500으로 나눈 몫을 count에 더한다. 1260 / 500 = 2이므로 2가 count에 더해진다.
2. num값을 500으로 나눈 나머지 값으로 바꾼다. 1260 % 500 이므로 260이 된다.
3. 그 다음은 100을 나눈 몫인 2를 count에 더하고, 다시 나머지 값으로 바꾸면 60.
4. 다음은 50으로 나눈 몫인 1을 count에 더하고, 다시 나머지 값으로 바꾸면 10.
5. 마지막으로 10으로 나눈 몫인 1을 count에 더한다.

이렇게 최소한의 동전 개수는 6개임을 알 수 있다.


화폐의 종류가 K개라고 했을때 코드의 시간 복잡도는 O(K)이다. 즉 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고 거슬러 줘야 하는 금액의 크기와는 무관하다.

### 그리디 알고리즘의 정당성

