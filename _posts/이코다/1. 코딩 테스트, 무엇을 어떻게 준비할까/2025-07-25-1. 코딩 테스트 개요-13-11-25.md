---
layout: post
title: 1. 코딩 테스트 개요
date: 2025-07-25 13:11:25 +0900
categories:
  - 이코다
  - 1. 코딩 테스트, 무엇을 어떻게 준비해야 할까?
tags:
published: true
math: true
---
## 3. 복잡도
복잡도는 알고리즘의 성능을 나타내는 척도며 2가지로 나뉜다.

- **시간 복잡도**<br>특정한 크기의 입력에 대하여 일고리즘이 얼마나 오래 걸리는지를 의미
- **공간 복잡도**<br>특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미

동일 기능을 수행하는 알고리즘이 있다면 복잡도가 낮을수록 좋은 알고리즘이다.

복잡도를 측정함으로써 다음 2가지를 계산할 수 있다.

- **시간 복잡도:** 필요한 연산의 횟수
- **공간 복잡도:** 필요한 메모리의 양

효율적인 알고리즘을 사용한다고 했을 때 시간과 공간 복잡도는 일종의 거래 관계가 성립한다. 둘 다 챙길 수는 없다는 말이다. 연산 속도가 조금 느려지는 대신 메모리를 덜 차지하거나, 아니면 메모리를 더 차지하는 대신 연산 속도를 빠르게 만들 수 있다. 이때 메모리를 더 소모하면서 얻을 수 있는 시간적 이점이 매우 큰 경우가 종종 있으며, 이 기법을 메모리제이션(Memorization) 이라고 한다, 이 내용은 8장에 나옴.

### 시간 복잡도
보통 알고리즘 문제를 풀 때 복잡도라고 하면 시간 복잡도를 의미한다. 처음 접하는 사람들이 어려워 하는 부분이 시간 제한이다. 프로그램을 비효율적으로 작성하면 시간 제한을 넘겨 오답 처리 되기 때문이다. 

시간 복잡도를 표현할 때는 빅오(Big-O) 표기법을 사용한다. 이 표기법은 가장 빠르게 증가하는 항만을 고려하는 표기법이다. 함수의 상한만을 나타낸다고 보면 된다. 예를 들어 N개의 데이터가 있을 때 모든 데이터를 하나씩 확인하며 그 값을 합계 변수에 더해주는 식으로 알고리즘을 작성한다면...

```java
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
        int[] arrays = {12,54,23,29,11};  
        int result = 0;  
  
        for (int i : arrays) {  
            result += i;  
        }  
  
        bw.write(Integer.toString(result));  
  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

위 코드는 5개의 데이터를 차례로 총 5회 더한다. 여기서 연산 횟수는 N에 비례한다. 때문에 N의 크기에 따라서 무수히 많거나 적게 연산을 하게 될 것이다. 따라서 가장 영향력이 큰 부분은 N에 비례하여 연산을 수행하는 반복문 부분이다. 이때 시간 복잡도를 O(N)으로 표기한다.

그럼 아래와 같은 코드의 시간 복잡도는 얼마일까?

```java
...
	int a = 1;
	int b = 13;
	bw.write(a + b);
...
```

a와 b에 값을 대입하는 연산과 출력 함수를 무시하고 보면 연산 횟수는 1이다. 왜냐면 단순 더하기 연산 한 번만 수행되기 때문이다. 이는 상수 연산이기 때문에 시간 복잡도는 O(1)로 표현할 수 이다.

그럼 이번에는 이 코드는 어떤 시간 복잡도를 가질까?

```java
int[] arrays = {1,2,3,4,5};
int temp = 0;

for (int i = 0; i < arrays.length; i++) {
	for (int j = 0; j < arrays.length; j++) {
		temp += i * j;
		bw.write(temp)
	}
}
```

데이터의 개수가 N개일 때, O(N²)의 시간 복잡도를 가진다. 간단한 2중 반복문이라 N x N만큼의 연산이 필요하다는 것을 유추할 수 있다. 그렇다고 모든 2중 반복문의 시간 복잡도가 O(N²)는 아니다. 내부적으로 다른 함수를 호출할수도 있기 때문에 내부의 함수의 시간 복잡도까지 고려해야 한다. 따라서 소스코드를 정확히 분석 후 시간 복잡도를 계산해야 한다는 것을 주의해야한다.

반면 6장에서 배우게 될 퀵 정렬의 평균 시간 복잡도는 O(NlogN)이지만, 최악일 경우에는 O(N²)이다. 일반적으로 코테에서는 최악을 먼저 생각해야한다. 
