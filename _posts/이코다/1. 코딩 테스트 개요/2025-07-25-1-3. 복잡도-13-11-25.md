---
layout: post
title: 1-3. 복잡도
date: 2025-07-25 13:11:25 +0900
categories:
  - 이코다
  - 1장
tags:
---
복잡도는 알고리즘의 성능을 나타내는 척도며 2가지로 나뉜다.

- **시간 복잡도**<br>특정한 크기의 입력에 대하여 일고리즘이 얼마나 오래 걸리는지를 의미
- **공간 복잡도**<br>특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미

동일 기능을 수행하는 알고리즘이 있다면 복잡도가 낮을수록 좋은 알고리즘이다.

복잡도를 측정함으로써 다음 2가지를 계산할 수 있다.

- **시간 복잡도:** 필요한 연산의 횟수
- **공간 복잡도:** 필요한 메모리의 양

효율적인 알고리즘을 사용한다고 했을 때 시간과 공간 복잡도는 일종의 거래 관계가 성립한다. 둘 다 챙길 수는 없다는 말이다. 연산 속도가 조금 느려지는 대신 메모리를 덜 차지하거나, 아니면 메모리를 더 차지하는 대신 연산 속도를 빠르게 만들 수 있다. 이때 메모리를 더 소모하면서 얻을 수 있는 시간적 이점이 매우 큰 경우가 종종 있으며, 이 기법을 메모리제이션(Memorization) 이라고 한다, 이 내용은 8장에 나옴.

## 시간 복잡도
보통 알고리즘 문제를 풀 때 복잡도라고 하면 시간 복잡도를 의미한다. 처음 접하는 사람들이 어려워 하는 부분이 시간 제한이다. 프로그램을 비효율적으로 작성하면 시간 제한을 넘겨 오답 처리 되기 때문이다. 

시간 복잡도를 표현할 때는 빅오(Big-O) 표기법을 사용한다. 이 표기법은 가장 빠르게 증가하는 항만을 고려하는 표기법이다. 함수의 상한만을 나타낸다고 보면 된다. 예를 들어 N개의 데이터가 있을 때 모든 데이터를 하나씩 확인하며 그 값을 합계 변수에 더해주는 식으로 알고리즘을 작성한다면...

```java
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
        int[] arrays = {12,54,23,29,11};  
        int result = 0;  
  
        for (int i : arrays) {  
            result += i;  
        }  
  
        bw.write(Integer.toString(result));  
  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

위 코드는 5개의 데이터를 차례로 총 5회 더한다. 여기서 연산 횟수는 N에 비례한다. 때문에 N의 크기에 따라서 무수히 많거나 적게 연산을 하게 될 것이다. 따라서 가장 영향력이 큰 부분은 N에 비례하여 연산을 수행하는 반복문 부분이다. 이때 시간 복잡도를 O(N)으로 표기한다.

그럼 아래와 같은 코드의 시간 복잡도는 얼마일까?

```java
...
	int a = 1;
	int b = 13;
	bw.write(a + b);
...
```

a와 b에 값을 대입하는 연산과 출력 함수를 무시하고 보면 연산 횟수는 1이다. 왜냐면 단순 더하기 연산 한 번만 수행되기 때문이다. 이는 상수 연산이기 때문에 시간 복잡도는 O(1)로 표현할 수 이다.
