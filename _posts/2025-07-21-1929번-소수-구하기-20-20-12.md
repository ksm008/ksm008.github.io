---
layout: post
title: 1929번 - 소수 구하기
date: 2025-07-21 20:20:12
categories:
  - 백준
  - 문제
---
소수를 구하는 방법으로는 2부터 n-1까지 전부 나누어보는 브루트 포스 방법도 있다. 
- ex) n = 7 | 2,3,4,5,6 전부 나누어 지지 않음 -> 소수이다.
- ex) n = 9 | 2로 나누어 지지 않지만 3으로 나누어진다 -> 소수가 아니다.

하지만 n이 1,000,000을 넘어가는 큰 숫자라고 한다면, 연산 횟수가 어마어마하게 커질 것이다. 최악의 경우 시간 복잡도가 O(n)이기 때문이다. 너무 느리고 중복되는 검사가 많아지기 때문에 많은 양의 소수를 구할때는 에라토스테네스의 체를 사용한다. (에라토스테네스의 체의 시간 복잡도는 O(N log log N)이다)

물론 소수 판별 대상이 적거나, 구현이 단순해야 할 상황이라면 브루트 포스도 괜찮은 선택이 될 수 있다.

# 에라토스테네스의 체

> 작은 소수의 배수를 하나씩 지우면 남는 수는 모두 소수이다.

고대 그리스의 수학자, 에라토스테네스가 만든 방법이다. 

개념은 아래와 같다.

1. 2부터 시작하는 숫자를 나열한다.
ex) 2,3,4,5,6,7,8...
2. 가장 작은 수부터 시작하여 그 수의 배수를 전부 지운다.
ex) 2가 가장 작고, 소수이다 -> 2의 배수인 4, 6, 8...을 지운다.
3. 계속해서 올라가면서 똑같이 진행한다.
ex) 3은 소수이다 -> 3의 배수인 3, 6, 9...를 지운다.

여기서 2의 배수인 4,6...이 지워졌기 때문에 3 다음에는 4가 아닌 5가 바로 온다. 이후 똑같이 5의 배수를 전부 없애고 나면 그 다음도 3의 배수인 6, 9...가 지워졌기 때문에 5 다음에는 6이 아닌 7이 오게 된다.

에라토스테네스의 체는 기본적으로 제거되지 않은 숫자들은 전부 소수이다. 때문에 특정 수의 배수들을 전부 지우고 다음에 있는 수가 소수인지 아닌지 판정하지 않아도 된다. 

[백준 1929번 - 소수 구하기](https://www.acmicpc.net/problem/1929) 문제를 해당 개념을 사용하여 풀 수 있다.

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader  br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter  bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] str = br.readLine().split(" ");
        int M = Integer.parseInt(str[0]);
        int N = Integer.parseInt(str[1]);

        boolean[] isPrime = new boolean[N + 1];

        // 초기화: 일단 모두 true로 두고, 0과 1은 소수가 아님
        for (int i = 2; i <= N; i++) {
            isPrime[i] = true;
        }

        // 에라토스테네스의 체 시작
        for (int i = 2; i * i <= N; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= N; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // M 이상 N 이하 출력
        for (int i = M; i <= N; i++) {
            if (isPrime[i]) {
                bw.write(i + "\n");
            }
        }

        bw.flush();
        bw.close();
        br.close();
    }
}
```


