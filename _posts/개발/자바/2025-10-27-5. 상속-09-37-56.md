---
layout: post
title: 5. 상속
date: 2025-10-27 09:37:56 +0900
categories:
  - 개발
  - 자바
published: true
math: true
tags:
  - 자바
  - 상속
---
## 5.1 상속의 개념
객체 지향에서 상속이란 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것.

여기서 중요한 것은, 상속은 클래스 사이의 상속이다. 객체 사이의 상속이 아니다. 따라서 자식 객체는 자식 클래스와 부모 클래스에 만들어진 모든 멤버를 가지고 생성된다.
(클래스는 설계도, 객체는 실제로 만들어진 존재.)

```java
class Animal {
    void eat() { System.out.println("먹는다"); }
}

class Dog extends Animal {
    void bark() { System.out.println("짖는다"); }
}
```

Dog는 Animal을 상속했다. 즉 Dog 클래스가 Animal 클래스의 속성과 메서드를 물려받았다. 여기서 Dog d = new Dog(); 를 하게 되면 Dog 객체만 생성된다. Animal 객체가 생성되어 Dog 객체를 상속시키는 것이 아니라는 뜻.

### 상속의 필요성
상속은 클래스끼리 겹치는 코드가 생길 때 유용하다.
4개의 클래스에 공통으로 들어가는 멤버나 메소드가 있다고 가정하자. 이 때, 하나의 멤버에 오류가 있어 수정하게 되면 4개의 클래스를 모두 수정해야 한다. 이렇게 되면 클래스의 유지 보수가 번거롭게 된다.

이를 상속을 사용하게 되면 간단하게 해결된다. 

객체 지향에서 상속이 가져다주는 장점을 간략히 정리하면 다음과 같다.

- 클래스의 간결화 - 멤버의 중복 작성 불필요
- 클래스 관리 용이 - 클래스들의 계층적 분류
- 소프트웨어 생산성 향상 - 클래스 재사용과 확장 용이

## 5.2 클래스 상속과 객체

### 자바의 상속 선언
자바에서는 부모 클래스를 슈퍼 클래스(super class), 상속받는 자식 클래스를 서브 클래스 (sub class)라고 부른다. 상속을 선언할 때는 확장시킨다는 의미의 **extends** 키워드를 사용한다. 

```java
public class Person {
	...
}

public class Student extends Person {
	...
}

public class StudentWorker extends Student {
	...
}
```

StudentWorker는 Student 클래스를 상속받고, Student 클래스는 Person 클래스를 상속받는다. 따라서 StudentWorker는 Student, Person의 필드와 메소드를 자동으로 상속받는다.

### 상속과 객체
#### 예제 5-1 | 클래스 상속 만들기 - Point와 ColorPoint 클래스
```java
class Point {  
    private int x , y;  
    public void set(int x, int y) {  
        this.x = x; this.y = y;  
    }  
    public void showPoint() {  
        System.out.println("(" + x + ", " + y + ")");  
    }  
}  
  
class ColorPoint extends Point {  
    private String color;  
    public void setColor(String color) {  
        this.color = color;  
    }  
    public void showColorPoint() {  
        System.out.print(color);  
        showPoint();  
    }  
}  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        Point p  = new Point();  
        p.set(1,2);  
        p.showPoint();  
  
        ColorPoint cp = new ColorPoint();  
        cp.set(3,4);  
        cp.setColor("red");  
        cp.showColorPoint();  
    }  
}
```

### 자바 상속의 특징

- **자바에서는 클래스의 다중 상속을 지원하지 않는다.**
- **상속 횟수에 제한은 없다.**
- **자바에서 만든 계층 구조의 최상위에 java.lang.Object 클래스가 있다.**
	- 모든 클래스의 조상이 java.lang.Object. Object 클래스는 6장에서 설명한다.

## 5.3 상속과 protected 접근 지정자
### 슈퍼 클래스에 대한 접근 지정

- 슈퍼 클래스의 private 멤버
	- 다른 어떤 클래스에서도 접근 불가.
- default 멤버
	- 같은 패키지 내의 모든 클래스가 가능
- public 멤버
	- 같은, 다른 패키지에 있는 모든 클래스가 가능
- protected 멤버
	- 같은, 다른 패키지에 있는 서브 클래스만 가능

## 5.4 상속과 생성자
서브 클래스와 슈퍼 클래스 둘 다 각 생성자를 가지고 있다.

Q: 서브 클래스 객체가 생성될 때 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행되는가? 아니면 서브 클래스의 생성자만 실행되는가?
A: 둘 다 실행된다. 이 때 생성자는 객체를 생성하는 역할이 아닌 초기화를 담당한다. 초기화는 메모리를 '확보'하는 역할. 

Q: 서브 클래스와 슈퍼 클래스의 생성자 중 누가 먼저 실행되는가?
A: 슈퍼 클래스 -> 서브 클래스 순서. 호출과 실행은 서로 다르다.

### 서브 클래스에서 슈퍼 클래스 생성자 선택
슈퍼 클래스에 여러 개의 생성자가 있는 경우, 컴파일러는 슈퍼 클래스의 기본 생성자를 호출하도록 컴파일한다.

#### 슈퍼 클래스의 기본 생성자가 자동 선택되는 경우
개발자의 명시적 지시가 없으면 슈퍼 클래스에서 만들어진 기본 생성자가 선택됨.

#### super()를 이용하여 명시적으로 슈퍼 클래스의 생성자 선택
super()를 사용하여 슈퍼 클래스의 생성자를 명시적으로 호출할 수 있다.

## 5.5 업캐스팅과 instanceof 연산자

캐스팅 = 타입 변환. 

### 업캐스팅
서브 클래스의 객체에 대한 레퍼런스를 슈퍼 클래스 타입으로 변환하는 것.

```java
Person p;
Student s = new Student();
p = s;
```

Person 타입 p에 Student 객체를 가리키도록 함. 이 때, Student의 멤버에는 접근할 수 없음 (내부는 Student지만 변수의 타입은 Person이므로 p.student필드or메소드 는 존재하지 않는다)

따라서 업캐스팅한 레퍼런스로는 객체 내 모든 멤버에 접근할 수 없고, 슈퍼 클래스의 멤버만 접근할 수 있다.

### 다운캐스팅

반대로 하는 것을 다운캐스팅이라고 한다. 

```java
Person p = new Student("이재문");
Student s = (Student)p;
```

이 때 업캐스팅은 명시적 타입 변환을 하지 않았지만, 다운캐스팅은 반드시 타입 변환을 표기해야 한다.

### 업캐스팅과 instanceof 연산자

만약 업캐스팅을 한 경우, 객체의 진짜 클래스 타입을 구분하기 힘들어진다 (`Person P = new Student();`)

#### instanceof 연산자 사용
레퍼런스가 가리키는 객체가 어떤 클래스 타입인지 구분하기 위한 instanceof가 있다. 티런 값은 boolean 값으로 레퍼런스가 가리키는 객체가 해당 클래스 타입의 객체면 true, 아니라면 false를 반환한다.

## 5.6 메소드 오버라이딩
### 메소드 오버라이딩의 개념
메소드 오버라이딩은 슈퍼 클래스와 서브 클래스의 메소드 사이에 발생하는 관계. 슈퍼 클래스에 선언된 메소드와 같은 이름, 같은 리턴 타입, 같은 매개 변수 리스트를 갖는 메소드를 서브클래스에서 **재작성**하는 것.

슈퍼 클래스에 있는 메소드로 원하는 목적을 이룰 수 없을 때 동일한 이름의 메소드를 서브 클래스에서 다시 작성가능.

오버라이딩된 메소드는 슈퍼 클래스의 메소드를 무시한다. 이런 처리를 **동적 바인딩**이라고 부르며 메소드 오버라이딩은 동적 바인딩을 유발한다.

#### 오버라이딩된 메소드 호출
오버라이딩의 진정한 목적은 업캐스팅된 객체의 메소드를 호출 시 확실하게 알 수 있다.
업캐스팅에 의해 슈퍼 클래스 레퍼런스로 오버라이딩된 메소드를 호출해도, 서브 클래스에 오버라이딩된 메소드가 있다면 서브 클래스의 메소드를 호출한다.

> **@Override 어노테이션**<br>서브 클래스에서 오버라이딩 메소드를 작성하다가 이름을 다르게 작성하여 오버라이딩이 되지 않는 경우를 방지하기 위해 @Override 어노테이션을 사용할 수 있다.
{: .prompt-info}

### 메소드 오버라이딩의 제약 사항

- **슈퍼 클래스의 메소드와 동일한 원형으로 작성한다.**
	- 이름, 리턴 타입, 매개변수 타입이 다르면 오류 발생
- **슈퍼 클래스 메소드의 접근지정자보다 접근의 범위를 줄여 오버라이딩 할 수 없다,**
	- 접근 지정자는 public, protected, default, private 순으로 좁아진다. protected로 지정된 슈퍼 클래스의 메소드를 private으로 지정은 불가능하다는 이야기.
- **static이나 private / final로 선언한 메소드는 서브 클래스에서 오버라이딩 할 수 없다.**

#### 오버라이딩과 super 키워드
super.슈퍼클래스의멤버 를 사용하여 슈퍼 클래스의 메소드를 사용할 수 있다.

#### 오버로딩과 오버라이딩
오버로딩은 한 클래스나 상속 관계에 있는 클래스들 사이에 메소드의 이름은 같지만, 매개변수 타입이나 개수가 다르게 작성하는 경우이다. 오버라이딩은 상속 관계에서만 성립되지만, 오버로딩은 동일한 클래스, 혹은 상속 관계 둘 다 가능하다. 여기서 오버로딩은 컴파일 시점에 어떤 메소드를 부를지 정해지므로 정적 바인딩에 해당한다.

## 5.7 추상 클래스

추상 클래스는 상속에서 슈퍼 클래스로 사용됨.

### 추상 메소드
추상 메소드란 선언은 되어있지만 코드가 구현되어 있지 않은 껍데기 메소드이다.
추상 메소드를 작성하려면 abstract 키워드와 함께 원형만 선언하고 코드를 작성하지 않는다.

### 추상 클래스 만들기
추상 클래스가 되는 경우는 아래의 2가지이며, 모두 abstract 키워드로 선언해야 한다.

- 추상 메소드를 포함하는 클래스

```java
abstract Shape() {
	public Shape() {}
	public void paint() { draw(); }
	abstract public void draw();
}
```

- 추상 메소드가 없지만 abstract로 선언한 클래스

```java
abstract class MyComponent {
	String name;
	public void load(String name) {
		this.name = name;
	}
}
```

위 코드의 Shape와 MyComponent 모두 추상 클래스이다.
추상 메소드를 가지고 있으면 반드시 추상 클래스로 선언되어야 한다. 아니면 오류가 난다.

### 추상 클래스는 객체를 생성할 수 없다
응용프로그램은 추상 클래스의 객체를 생성할 수 없다. 추상 클래스는 객체를 생성할 목적으로 만드는 클래스가 아니다. 

### 추상 클래스의 상속
추상 클래스를 단순히 상속받는 서브 클래스는 추상 클래스가 된다. 그러므로 서브 클래스에도 abstract를 붙여 추상 클래스임을 명시해야 오류가 발생하지 않는다. 만약 상속받는 서브 클래스의 메소드를 오버라이딩 하여 추상 메소드를 없애버리면 일반 서브 클래스가 된다.

### 추상 클래스의 구현과 목적
추상 클래스의 구현이란, 슈퍼 클래스에 선언된 모든 추상 메소드를 서브 클래스에서 오버라이딩하여 실행 가능한 코드로 구현하는 것을 말한다. 

추상 클래스는 추상 메소드를 통해 서브 클래스가 구현할 메소드를 명료하게 알려주는 인터페이스의 역할을 하고, 서브 클래스는 추상 메소드를 목적에 맞게 구현하는 다형성을 실현할 수 있다.

## 5.8 인터페이스

소프트웨어를 규격화된 모듈로 만들고, 서로 인터페이스가 맞는 모듈을 조립하듯 응용프로그램을 작성할 수 있다.

### 자바의 인터페이스
자바의 인터페이스는 interface 키워드를 사용하여 클래스를 선언하듯 선언한다. 

```java
interface PhoneInterface {
	public static final int TIMEOUT = 10000;
	public abstract void sendCall();
	public abstract void receiveCall();
	public default void printLogo() {
		System.out.println("** Phone **");
	}
}
```

#### - 인터페이스 구성
인터페이스는 다음 5종류의 멤버로 구성되며, 필드를 만들 수 없다.

- 상수와 추상 메서도
- default 메소드
- private 메소드
- static 메소드

추상 메소드는 public abstract로 정해져 있으며, 생략될 수 있고, 다른 접근 지정으로 지정될 수 없다. default, private, static 메소드들은 모두 인터페이스 내에 코드가 작성되어 있어야 한다. default 메소드의 접근 지정은 public으로 고정되어 있다. private 메소드는 인터페이스 내에서만 호출 가능하다. static 메소드의 경우 접근 지정이 생략되면 public이며, private으로 지정될 수 있다.

#### **- 인터페이스는 객체를 생성할 수 없다**

인터페이스는 구현되지 않은 추상 메소드를 가질 수 있기 때문에 객체를 생성할 수 없다.

#### **- 인터페이스 타입의 레퍼런스 변수는 선언 가능하다**
#### **- 인터페이스끼리 상속된다**
#### **- 인터페이스를 상속받아 클래스를 작성하면 인터페이스의 모든 추상 메소드를 구현하여야 한다**

자바의 인터페이스는 상속받을 서브 클래스에게 구현할 메소드들의 원혀을 모두 알려주오, 클래스가 스스로의 목적에 맞게 메소드를 구현하도록 하는 것이 목적이다.

### 인터페이스 구현

인터페이스 구현이란 implements 키워드를 사용하여 인터페이스의 모든 추상 메소드를 구현한 클래스를 작성하는 것을 말한다. 

```java
class SamsungPhone implements PhoneInterface {
	// 모든 추상 메소드를 구현
	public void sendCall() { System.out.println("띠리리리링"); }
	public void receiveCall() { System.out.println("전화가 왔습니다"); }
	// 메소드 추가 작성
	public void flash() { Sysyem.out.println("전화기에 불이 켜졌습니다.") ; }
}
```

모든 추상 메소드를 구현하고, flash() 메소드는 추가 구현, 이미 구현된 printLogo는 그대로 물려받는다.

### 인터페이스 상속

클래스는 인터페이스를 상속받을 수 없고, 인터페이스끼리만 상속이 가능하다. 상속을 통해 기존 인터페이스에 새로운 규격을 추가한 새로운 인터페이스를 만들 수 있으며 역시 extends를 사용한다.

```java
interface MobilePhoneInterface extends PhoneInterface {
	void sendSMS();
	void receiveSMS();
}
```

자바는 인터페이스의 다중 상속을 허용한다.

```java
interface MP3Interface {
	void play();
	void stop();
}

interface MusicPhoneInterface extends MobilePhoneInterface, MP3Interface {
	void playMP3RingTone();
}
```

### 인터페이스의 목적

인터페이스는 스펙을 주어 클래스들이 그 기능을 서로 다르게 구현할 수 있도록 하는 클래스의 규격 선언, 클래스의 다형성을 실현하는 도구.

클래스는 다중의 인터페이스를 상속받을 수 있고, 클래스 상속과 함께 인터페이스 구현을 받을 수 있다.

## Open Challenge

사람과 컴퓨터가 묵찌빠 게임을 하는 프로그램을 만들어본다. 게임의 원칙은 다음과 같다.

- 사람과 컴퓨터의 이름을 입력받고 시작한다.
- 게임에서 주도권을 가진 선수를 오너(owner)라고 하며, 사람이 먼저 오너가 된다.
- 사람은 사용자로부터 묵, 찌, 빠 중 하나를 입력받는다. 잘못된 입력이 들어오면 다시 입력받는다. 컴퓨터는 묵, 찌, 빠 중에서 랜덤하게 한 개를 선택하고 "결정하였습니다"를 출력한다.
- 사람이 오너인 경우 컴퓨터가 낸 것과 비교하여 같으면 사람이 승자가 되고 프로그램은 종료한다. 컴퓨터가 오너인 경우도 마찬가지다. 승자가 결정되면 프로그램은 종료한다. 
- 사람과 컴퓨터가 낸 것이 달라 승자가 없는 경우, 가위 바위 보 규칙에 따라 이긴 사람이 오너가 된다.
이 문제를 풀 때는 힌트를 참고하여 사람과 컴퓨터의 공통 행동을 Player 추상 클래스로 만들고 사람은 Human, 컴퓨터는 Computer 클래스를 만들고 이들은 Player를 상속받는 구조로 작성하라.

```
***** 묵찌빠 게임을 시작합니다. *****
선수이름 입력 >>황기태
컴퓨터이름 입력 >>AI
2명의 선수를 생성 완료하였습니다.

황기태>>묵
AI>> 결정하였습니다.
황기태 : 묵, AI : 빠
오너가 AI로 변경되었습니다.

AI>> 결정하였습니다.
황기태>>빠
황기태 : 빠, AI: 찌
오너가 황기태로 변경되었습니다.

황기태>>삐
묵 찌 빠 중에서 다시 입력하세요.
황기태>>빠
AI>> 결정하였습니다.
황기태 : 빠, AI : 빠

황기태이 이겼습니다.
게임을 종료합니다.
```

> **힌트**<br>- 이 문제는 상속 구조로 작성하자. 선수를 표현하는 Player 클래스를 만들고, Player를 상속받은 Human과 Computer 클래스를 작성한다.
{: .prompt-info}


