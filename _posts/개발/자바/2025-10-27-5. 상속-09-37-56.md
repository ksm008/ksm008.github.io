---
layout: post
title: 5. 상속
date: 2025-10-27 09:37:56 +0900
categories:
  - 개발
  - 자바
published: true
math: true
tags:
  - 자바
  - 상속
---
## 5.1 상속의 개념
객체 지향에서 상속이란 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것.

여기서 중요한 것은, 상속은 클래스 사이의 상속이다. 객체 사이의 상속이 아니다. 따라서 자식 객체는 자식 클래스와 부모 클래스에 만들어진 모든 멤버를 가지고 생성된다.
(클래스는 설계도, 객체는 실제로 만들어진 존재.)

```java
class Animal {
    void eat() { System.out.println("먹는다"); }
}

class Dog extends Animal {
    void bark() { System.out.println("짖는다"); }
}
```

Dog는 Animal을 상속했다. 즉 Dog 클래스가 Animal 클래스의 속성과 메서드를 물려받았다. 여기서 Dog d = new Dog(); 를 하게 되면 Dog 객체만 생성된다. Animal 객체가 생성되어 Dog 객체를 상속시키는 것이 아니라는 뜻.

### 상속의 필요성
상속은 클래스끼리 겹치는 코드가 생길 때 유용하다.
4개의 클래스에 공통으로 들어가는 멤버나 메소드가 있다고 가정하자. 이 때, 하나의 멤버에 오류가 있어 수정하게 되면 4개의 클래스를 모두 수정해야 한다. 이렇게 되면 클래스의 유지 보수가 번거롭게 된다.

이를 상속을 사용하게 되면 간단하게 해결된다. 

객체 지향에서 상속이 가져다주는 장점을 간략히 정리하면 다음과 같다.

- 클래스의 간결화 - 멤버의 중복 작성 불필요
- 클래스 관리 용이 - 클래스들의 계층적 분류
- 소프트웨어 생산성 향상 - 클래스 재사용과 확장 용이

## 5.2 클래스 상속과 객체

### 자바의 상속 선언
자바에서는 부모 클래스를 슈퍼 클래스(super class), 상속받는 자식 클래스를 서브 클래스 (sub class)라고 부른다. 상속을 선언할 때는 확장시킨다는 의미의 **extends** 키워드를 사용한다. 

```java
public class Person {
	...
}

public class Student extends Person {
	...
}

public class StudentWorker extends Student {
	...
}
```

StudentWorker는 Student 클래스를 상속받고, Student 클래스는 Person 클래스를 상속받는다. 따라서 StudentWorker는 Student, Person의 필드와 메소드를 자동으로 상속받는다.

### 상속과 객체
#### 예제 5-1 | 클래스 상속 만들기 - Point와 ColorPoint 클래스
```java
class Point {  
    private int x , y;  
    public void set(int x, int y) {  
        this.x = x; this.y = y;  
    }  
    public void showPoint() {  
        System.out.println("(" + x + ", " + y + ")");  
    }  
}  
  
class ColorPoint extends Point {  
    private String color;  
    public void setColor(String color) {  
        this.color = color;  
    }  
    public void showColorPoint() {  
        System.out.print(color);  
        showPoint();  
    }  
}  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        Point p  = new Point();  
        p.set(1,2);  
        p.showPoint();  
  
        ColorPoint cp = new ColorPoint();  
        cp.set(3,4);  
        cp.setColor("red");  
        cp.showColorPoint();  
    }  
}
```

### 자바 상속의 특징

- **자바에서는 클래스의 다중 상속을 지원하지 않는다.**
- **상속 횟수에 제한은 없다.**
- **자바에서 만든 계층 구조의 최상위에 java.lang.Object 클래스가 있다.**
	- 모든 클래스의 조상이 java.lang.Object. Object 클래스는 6장에서 설명한다.

## 5.3 상속과 protected 접근 지정자
### 슈퍼 클래스에 대한 접근 지정

- 슈퍼 클래스의 private 멤버
	- 다른 어떤 클래스에서도 접근 불가.
- default 멤버
	- 같은 패키지 내의 모든 클래스가 가능
- public 멤버
	- 같은, 다른 패키지에 있는 모든 클래스가 가능
- protected 멤버
	- 같은, 다른 패키지에 있는 서브 클래스만 가능

## 5.4 상속과 생성자
서브 클래스와 슈퍼 클래스 둘 다 각 생성자를 가지고 있다.

Q: 서브 클래스 객체가 생성될 때 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행되는가? 아니면 서브 클래스의 생성자만 실행되는가?
A: 둘 다 실행된다. 이 때 생성자는 객체를 생성하는 역할이 아닌 초기화를 담당한다. 초기화는 메모리를 '확보'하는 역할. 

Q: 서브 클래스와 슈퍼 클래스의 생성자 중 누가 먼저 실행되는가?
A: 슈퍼 클래스 -> 서브 클래스 순서. 호출과 실행은 서로 다르다.

### 서브 클래스에서 슈퍼 클래스 생성자 선택
슈퍼 클래스에 여러 개의 생성자가 있는 경우, 컴파일러는 슈퍼 클래스의 기본 생성자를 호출하도록 컴파일한다.

#### 슈퍼 클래스의 기본 생성자가 자동 선택되는 경우
개발자의 명시적 지시가 없으면 슈퍼 클래스에서 만들어진 기본 생성자가 선택됨.

#### super()를 이용하여 명시적으로 슈퍼 클래스의 생성자 선택
super()를 사용하여 슈퍼 클래스의 생성자를 명시적으로 호출할 수 있다.

## 5.5 업캐스팅과 instanceof 연산자

캐스팅 = 타입 변환. 

### 업캐스팅
서브 클래스의 객체에 대한 레퍼런스를 슈퍼 클래스 타입으로 변환하는 것.

```java
Person p;
Student s = new Student();
p = s;
```

Person 타입 p에 Student 객체를 가리키도록 함. 이 때, Student의 멤버에는 접근할 수 없음 (내부는 Student지만 변수의 타입은 Person이므로 p.student필드or메소드 는 존재하지 않는다)

따라서 업캐스팅한 레퍼런스로는 객체 내 모든 멤버에 접근할 수 없고, 슈퍼 클래스의 멤버만 접근할 수 있다.

### 다운캐스팅

반대로 하는 것을 다운캐스팅이라고 한다. 

```java
Person p = new Student("이재문");
Student s = (Student)p;
```

이 때 업캐스팅은 명시적 타입 변환을 하지 않았지만, 다운캐스팅은 반드시 타입 변환을 표기해야 한다.

### 업캐스팅과 instanceof 연산자

만약 업캐스팅을 한 경우, 객체의 진짜 클래스 타입을 구분하기 힘들어진다 (`Person P = new Student();`)

#### instanceof 연산자 사용
레퍼런스가 가리키는 객체가 어떤 클래스 타입인지 구분하기 위한 instanceof가 있다. 티런 값은 boolean 값으로 레퍼런스가 가리키는 객체가 해당 클래스 타입의 객체면 true, 아니라면 false를 반환한다.

## 5.6 메소드 오버라이딩
### 메소드 오버라이딩의 개념
메소드 오버라이딩은 슈퍼 클래스와 서브 클래스의 메소드 사이에 발생하는 관계. 슈퍼 클래스에 선언된 메소드와 같은 이름, 같은 리턴 타입, 같은 매개 변수 리스트를 갖는 메소드를 서브클래스에서 **재작성**하는 것.

슈퍼 클래스에 있는 메소드로 원하는 목적을 이룰 수 없을 때 동일한 이름의 메소드를 서브 클래스에서 다시 작성가능.

오버라이딩된 메소드는 슈퍼 클래스의 메소드를 무시한다. 이런 처리를 **동적 바인딩**이라고 부르며 메소드 오버라이딩은 동적 바인딩을 유발한다.

#### 오버라이딩된 메소드 호출
오버라이딩의 진정한 목적은 업캐스팅된 객체의 메소드를 호출 시 확실하게 알 수 있다.
업캐스팅에 의해 슈퍼 클래스 레퍼런스로 오버라이딩된 메소드를 호출해도, 서브 클래스에 오버라이딩된 메소드가 있다면 서브 클래스의 메소드를 호출한다.

> **@Override 어노테이션**<br>서브 클래스에서 오버라이딩 메소드를 작성하다가 이름을 다르게 작성하여 오버라이딩이 되지 않는 경우를 방지하기 위해 @Override 어노테이션을 사용할 수 있다.
{: .prompt-info}

### 메소드 오버라이딩의 제약 사항

- **슈퍼 클래스의 메소드와 동일한 원형으로 작성한다.**
	- 이름, 리턴 타입, 매개변수 타입이 다르면 오류 발생
- **슈퍼 클래스 메소드의 접근지정자보다 접근의 범위를 줄여 오버라이딩 할 수 없다,**
	- 접근 지정자는 public, protected, default, private 순으로 좁아진다. protected로 지정된 슈퍼 클래스의 메소드를 private으로 지정은 불가능하다는 이야기.
- **static이나 private / final로 선언한 메소드는 서브 클래스에서 오버라이딩 할 수 없다.**
#### 오버라이딩과 super 키워드
super.슈퍼클래스의멤버 를 사용하여 슈퍼 클래스의 메소드를 사용할 수 있다.

#### 오버로딩과 오버라이딩
오버로딩은 한 클래스나 상속 관계에 있는 클래스들 사이에 메소드의 이름은 같지만, 매개변수 타입이나 개수가 다르게 작성하는 경우이다. 오버라이딩은 상속 관계에서만 성립되지만, 오버로딩은 동일한 클래스, 혹은 상속 관계 둘 다 가능하다. 여기서 오버로딩은 컴파일 시점에 어떤 메소드를 부를지 정해지므로 정적 바인딩에 해당한다.
## 5.7 추상 클래스

추상 클래스는 상속에서 슈퍼 클래스로 사용됨.

### 추상 메소드
추상 메소드란 선언은 되어있지만 코드가 구현되어 있지 않은 껍데기 메소드이다.
추상 메소드를 작성하려면 abstract 키워드와 함께 원형만 선언하고 코드를 작성하지 않는다.

### 추상 클래스 만들기
추상 클래스가 되는 경우는 아래의 2가지이며, 모두 abstract 키워드로 선언해야 한다.

- 추상 메소드를 포함하는 클래스

```java
abstract Shape() {
	public Shape() {}
	public void paint() { draw(); }
	abstract public void draw();
}
```

- 추상 메소드가 없지만 abstract로 선언한 클래스

```java
abstract class MyComponent {
	String name;
	public void load(String name) {
		this.name = name;
	}
}
```

위 코드의 Shape와 MyComponent 모두 추상 클래스이다.
추상 메소드를 가지고 있으면 반드시 추상 클래스로 선언되어야 한다. 아니면 오류가 난다.

### 추상 클래스는 객체를 생성할 수 없다
응용프로그램은 추상 클래스의 객체를 생성할 수 없다. 추상 클래스는 객체를 생성할 목적으로 만드는 클래스가 아니다. 

### 추상 클래스의 상속
추상 클래스를 단순히 상속받는 서브 클래스는 추상 클래스가 된다. 그러므로 서브 클래스에도 abstract를 붙여 추상 클래스임을 명시해야 오류가 발생하지 않는다. 만약 상속받는 서브 클래스의 메소드를 오버라이딩 하여 추상 메소드를 없애버리면 일반 서브 클래스가 된다.

## 5.8 인터페이스

