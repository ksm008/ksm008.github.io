---
layout: post
title: 4. 클래스와 객체
date: 2025-09-03 09:09:08 +0900
categories:
  - 개발
  - 자바
published: true
math: true
tags:
  - 자바
  - 클래스
---
### 클래스의 구성
- 클래스 선언부
	- class ~로 클래스를 선언한다.
- 필드와 메소드
	- 객채 내부에 저장할 멤버(클래스 내부의 구성 요소) 변수를 필드라고 부른다. 그리고 메소드를 지정할 수 있다.
- 접근 지정자
	- public, private 같은 접근 지정자를 붙여 다른 클래스에서 활용하거나 접근 가능하다는 걸 선언
- 생성자
	- 인스턴스를 생성할 때 사용한다.

## 3. 생성자
생성자는 클래스를 생성할 때 필드에 바로 값을 집어넣을 수 있게 해준다. 엄밀하게 정의를 이야기 한다면 객체의 초기화를 위해 실행되는 메소드라고 볼 수 있다.

```java
package JavaPrograming.Chap04;  
  
public class Circle {  
    int radius;  
    String name;  
  
    public Circle() {}  
      
    public Circle(int r, String n) {  
        radius = r; name = n;  
    }  
    public double getArea() {  
        return radius * radius * 3.14;  
    }  
  
    public static void main(String[] args) {  
        Circle pizza = new Circle(10, "자바피자");  
        double area = pizza.getArea();  
        System.out.println(pizza.name + "의 면적은 " + area);  
  
        Circle donut = new Circle();  
        donut.radius = 2;  
        donut.name = "자바도넛";  
        area = donut.getArea();  
        System.out.println(donut.name + "의 면적은 " + area);  
    }  
}
```

생성자는 여러개 존재할 수 있고 리턴 타입을 지정할 수 없다. 어떤 값도 리턴하지 않기 때문. 하지만 생성자 내부에서 return은 사용할 수 있다.

### this 레퍼런스
객체 자기 자신을 가리키는 레퍼런스이다. 

```java
...
	public Circle(int radius, String name) {  
	    radius = radius;  
	    name = name;  
	}
...
```

Circle 클래스 생성자의 매개변수에 필드와 똑같은 이름이 들어가있을 경우, 둘 다 매개변수 radius를 접근하기 때문에 필드를 변경하지 못한다. 때문에 매개변수의 이름이 다르거나, 아니면 this 레퍼런스를 통해 멤버 변수임을 알려줘야 한다.

```java
...
	public Circle(int radius, String name) {  
	    this.radius = radius;  
	    this.name = name;  
	}
...
```

또 메서드가 객체 자기 자신을 리턴할 수도 있다. 

```java
...
	public Circle getMe() {  
	    return this;  
	}
...
```

이와 같이 메소드의 리턴 타입을 객체 자신으로 하고 리턴값으로 this 레퍼런스를 주게 되면 getMe()는 자기 자신을 리턴하게 된다. 이러한 형태는 **메소드 체이닝**에 가장 흔하게 사용된다.

```java
class Circle {
    int radius;
    String name;

    public Circle setRadius(int radius) {
        this.radius = radius;
        return this;  // 자기 자신 리턴
    }

    public Circle setName(String name) {
        this.name = name;
        return this;
    }
}

public class Main {
    public static void main(String[] args) {
        Circle c = new Circle()
                        .setRadius(10)   
                        .setName("원");  // 계속 이어서 호출 가능
    }
}
```

메소드의 리턴 타입을 Circle로 지정하고 리턴 값을 this 레퍼런스로 지정하였다. new Circle()로 새로운 객체가 생성하고 메소드를 호출한 후에도 리턴 값이 자기 자신이기 때문에 계속해서 메소드를 호출할 수 있다. 만약 메소드 체이닝이 불가능하다면 `c.radius = 10; c.name = "원";` 같은 코드를 더 작성해야 한다. 

그 외에도 현재 객체를 리턴해서 재사용하거나 하는 등 여러 상황에서 사용할 수 있지만 이 정도만 알아둬도 괜찮을 것 같다. 메소드 체이닝 기법은 StringBuilder, Stream API, JPA Query 같은 곳에 쓰인다.

### this()로 다른 생성자 호출
```java
package JavaPrograming.Chap04;  
  
public class Book {  
    String title;  
    String author;;  
  
    void show() {  
        System.out.println("title: " + title);  
        System.out.println("author: " + author);  
    }  
  
    public Book() {  
        this("", "");  
        System.out.println("생성자 호출됨");  
    }  
  
    public Book(String title) {  
        this(title, "작자미상");  
    }  
  
    public Book(String title, String author) {  
        this.title = title;  
        this.author = author;  
    }  
  
    public static void main(String[] args) {  
        Book littlePrince = new Book("어린왕자", "생텍쥐페리");  
        Book loveStory = new Book("춘향전");  
        Book emptyBook = new Book();  
        loveStory.show();  
    }  
}
```

위 코드에서 Book()과 Book(String title)은 this()를 통해 Book(String title, String author)를 호출하고 있다. 
#### 주의할 점
- this()는 반드시 생성자 코드에서만 호출 가능
- 같은 클래스 내 다른 생성자를 호출할 때만 사용
- 생성자의 첫 문장이 되어야 함

### 객체 치환 시 주의할 점

= 연산자로 객체를 치환하게 되면 객체를 복사하는 것이 아니다,

```java
Circle ob1 = new Circle(1);
Circle ob2 = new Circle(2);

s = ob2;
ob1 = ob2;
```

ob1과 ob2은 각자 객체를 하나씩 생성하여 가리키고 있다. 이 때 ob1이 가리키는 객체를 ob2로 치환해버릴 경우, 원래 ob1이 가리키던 객체는 아무도 가리키고 있지 않기 때문에 더 이상 접근할 수 없는 상태가 된다. 이러한 객체를 가비지(garbage, 쓰레기)라고 부른다. 가비지는 자바 가상 기계에 의해 자동으로 수거, 재사용된다.

### CHECK TIME

#### 1. 다음 코드에서 잘못된 부분이 3군데 있다. 모두 수정하라.

```java
class Samp {
	int id;
	
	public void Samp(int x) {
		this.id = x;
	}
	
	public void Samp() {
		System.out.println("생성자 호출");
		this(0);
	}
```

1. 생성자에 void 처럼 리턴값 명시를 했음
2. this() 호출은 생성자 안에서만 가능하고 메소드에서는 불가능함 (리턴값 명시로 인해 메소드로 처리)
3. this() 호출을 가장 처음에 하지 않았음

```java
class Samp {
    int id;

    public Samp(int x) {
        this.id = x;
    }

    public Samp() {
        this(0); 
        System.out.println("생성자 호출");
    }
}
```

이러한 형태로 고칠 수 있다.

#### 2. 다음 코드는 오류를 포함하고 있다. 이유를 설명하고 올바르게 수정하라.

```java
class ConstructorExample {  
    int x;  
    public void setX(int x) {  
        this.x = x;  
    }  
    public int getX() {  
        return x;  
    }  
      
    public ConstructorExample(int x) {  
        this.x = x;  
    }  
      
    public static void main(String[] args) {  
        ConstructorExample a = new ConstructorExample();  
        int n = a.getX();  
    }  
}
```

이유: 클래스 안에 생성자가 하나라도 작성될 경우, 기본 생성자는 생성되지 않으므로 따로 만들어줘야 한다.

수정:
```java
...
	// 2가지 선택지가 있다.
	// 1. 기본 생성자를 추가하거나
    public ConstructorExample() {  
    }  
    
	// 2. 생성자에 매개변수를 추가하거나.  
    public static void main(String[] args) {  
        ConstructorExample a = new ConstructorExample(5);  
        int n = a.getX();  
    }  
...
```

#### 3. this와 this()의 차이를 설명하라
this는 현재 객체 자신에 대한 레퍼런스이고 this()는 클래스 내에서 생성자가 다른 생성자를 호출할 때 쓰는 코드이다.

## 4. 객체 배열
기본 타입 데이터 뿐만 아니라 객체를 원소로 하는 배열도 만들 수 있다. 
이때, 배열의 크기만큼 전부 객채를 하나씩 생성하여 각각 대입해주어야 한다. for문을 사용해 반복하여 하나씩 대입해주면 된다.

## 5. 메소드 활용
메소드 형식, 인자 전달, 메소드 오버로딩에 대해 설명한다.