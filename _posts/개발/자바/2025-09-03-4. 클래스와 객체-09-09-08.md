---
layout: post
title: 4. 클래스와 객체
date: 2025-09-03 09:09:08 +0900
categories:
  - 개발
  - 자바
published: true
math: true
tags:
  - 자바
  - 클래스
---
### 클래스의 구성
- 클래스 선언부
	- class ~로 클래스를 선언한다.
- 필드와 메소드
	- 객채 내부에 저장할 멤버(클래스 내부의 구성 요소) 변수를 필드라고 부른다. 그리고 메소드를 지정할 수 있다.
- 접근 지정자
	- public, private 같은 접근 지정자를 붙여 다른 클래스에서 활용하거나 접근 가능하다는 걸 선언
- 생성자
	- 인스턴스를 생성할 때 사용한다.

## 3. 생성자
생성자는 클래스를 생성할 때 필드에 바로 값을 집어넣을 수 있게 해준다. 엄밀하게 정의를 이야기 한다면 객체의 초기화를 위해 실행되는 메소드라고 볼 수 있다.

```java
package JavaPrograming.Chap04;  
  
public class Circle {  
    int radius;  
    String name;  
  
    public Circle() {}  
      
    public Circle(int r, String n) {  
        radius = r; name = n;  
    }  
    public double getArea() {  
        return radius * radius * 3.14;  
    }  
  
    public static void main(String[] args) {  
        Circle pizza = new Circle(10, "자바피자");  
        double area = pizza.getArea();  
        System.out.println(pizza.name + "의 면적은 " + area);  
  
        Circle donut = new Circle();  
        donut.radius = 2;  
        donut.name = "자바도넛";  
        area = donut.getArea();  
        System.out.println(donut.name + "의 면적은 " + area);  
    }  
}
```

생성자는 여러개 존재할 수 있고 리턴 타입을 지정할 수 없다. 어떤 값도 리턴하지 않기 때문. 하지만 생성자 내부에서 return은 사용할 수 있다.

### this 레퍼런스
객체 자기 자신을 가리키는 레퍼런스이다. 

```java
...
	public Circle(int radius, String name) {  
	    radius = radius;  
	    name = name;  
	}
...
```

Circle 클래스 생성자의 매개변수에 필드와 똑같은 이름이 들어가있을 경우, 둘 다 매개변수 radius를 접근하기 때문에 필드를 변경하지 못한다. 때문에 매개변수의 이름이 다르거나, 아니면 this 레퍼런스를 통해 멤버 변수임을 알려줘야 한다.

```java
...
	public Circle(int radius, String name) {  
	    this.radius = radius;  
	    this.name = name;  
	}
...
```

또 메서드가 객체 자기 자신을 리턴할 수도 있다. 

```java
...
	public Circle getMe() {  
	    return this;  
	}
...
```

이와 같이 메소드의 리턴 타입을 객체 자신으로 하고 리턴값으로 this 레퍼런스를 주게 되면 getMe()는 자기 자신을 리턴하게 된다. 이러한 형태는 **메소드 체이닝**에 가장 흔하게 사용된다.

```java
class Circle {
    int radius;
    String name;

    public Circle setRadius(int radius) {
        this.radius = radius;
        return this;  // 자기 자신 리턴
    }

    public Circle setName(String name) {
        this.name = name;
        return this;
    }
}

public class Main {
    public static void main(String[] args) {
        Circle c = new Circle()
                        .setRadius(10)   
                        .setName("원");  // 계속 이어서 호출 가능
    }
}
```

메소드의 리턴 타입을 Circle로 지정하고 리턴 값을 this 레퍼런스로 지정하였다. new Circle()로 새로운 객체가 생성하고 메소드를 호출한 후에도 리턴 값이 자기 자신이기 때문에 계속해서 메소드를 호출할 수 있다. 만약 메소드 체이닝이 불가능하다면 `c.radius = 10; c.name = "원";` 같은 코드를 더 작성해야 한다. 

그 외에도 현재 객체를 리턴해서 재사용하거나 하는 등 여러 상황에서 사용할 수 있지만 이 정도만 알아둬도 괜찮을 것 같다. 메소드 체이닝 기법은 StringBuilder, Stream API, JPA Query 같은 곳에 쓰인다.

### this()로 다른 생성자 호출
```java
package JavaPrograming.Chap04;  
  
public class Book {  
    String title;  
    String author;;  
  
    void show() {  
        System.out.println("title: " + title);  
        System.out.println("author: " + author);  
    }  
  
    public Book() {  
        this("", "");  
        System.out.println("생성자 호출됨");  
    }  
  
    public Book(String title) {  
        this(title, "작자미상");  
    }  
  
    public Book(String title, String author) {  
        this.title = title;  
        this.author = author;  
    }  
  
    public static void main(String[] args) {  
        Book littlePrince = new Book("어린왕자", "생텍쥐페리");  
        Book loveStory = new Book("춘향전");  
        Book emptyBook = new Book();  
        loveStory.show();  
    }  
}
```

위 코드에서 Book()과 Book(String title)은 this()를 통해 Book(String title, String author)를 호출하고 있다. 
#### 주의할 점
- this()는 반드시 생성자 코드에서만 호출 가능
- 같은 클래스 내 다른 생성자를 호출할 때만 사용
- 생성자의 첫 문장이 되어야 함

### 객체 치환 시 주의할 점

= 연산자로 객체를 치환하게 되면 객체를 복사하는 것이 아니다,

```java
Circle ob1 = new Circle(1);
Circle ob2 = new Circle(2);

s = ob2;
ob1 = ob2;
```

ob1과 ob2은 각자 객체를 하나씩 생성하여 가리키고 있다. 이 때 ob1이 가리키는 객체를 ob2로 치환해버릴 경우, 원래 ob1이 가리키던 객체는 아무도 가리키고 있지 않기 때문에 더 이상 접근할 수 없는 상태가 된다. 이러한 객체를 가비지(garbage, 쓰레기)라고 부른다. 가비지는 자바 가상 기계에 의해 자동으로 수거, 재사용된다.

### CHECK TIME

#### 1. 다음 코드에서 잘못된 부분이 3군데 있다. 모두 수정하라.

```java
class Samp {
	int id;
	
	public void Samp(int x) {
		this.id = x;
	}
	
	public void Samp() {
		System.out.println("생성자 호출");
		this(0);
	}
```

1. 생성자에 void 처럼 리턴값 명시를 했음
2. this() 호출은 생성자 안에서만 가능하고 메소드에서는 불가능함 (리턴값 명시로 인해 메소드로 처리)
3. this() 호출을 가장 처음에 하지 않았음

```java
class Samp {
    int id;

    public Samp(int x) {
        this.id = x;
    }

    public Samp() {
        this(0); 
        System.out.println("생성자 호출");
    }
}
```

이러한 형태로 고칠 수 있다.

#### 2. 다음 코드는 오류를 포함하고 있다. 이유를 설명하고 올바르게 수정하라.

```java
class ConstructorExample {  
    int x;  
    public void setX(int x) {  
        this.x = x;  
    }  
    public int getX() {  
        return x;  
    }  
      
    public ConstructorExample(int x) {  
        this.x = x;  
    }  
      
    public static void main(String[] args) {  
        ConstructorExample a = new ConstructorExample();  
        int n = a.getX();  
    }  
}
```

이유: 클래스 안에 생성자가 하나라도 작성될 경우, 기본 생성자는 생성되지 않으므로 따로 만들어줘야 한다.

수정:
```java
...
// 2가지 선택지가 있다.
// 1. 기본 생성자를 추가하거나
    public ConstructorExample() {  
    }  
    
// 2. 생성자에 매개변수를 추가하거나.  
    public static void main(String[] args) {  
        ConstructorExample a = new ConstructorExample(5);  
        int n = a.getX();  
    }  
...
```

#### 3. this와 this()의 차이를 설명하라
this는 현재 객체 자신에 대한 레퍼런스이고 this()는 클래스 내에서 생성자가 다른 생성자를 호출할 때 쓰는 코드이다.

## 4. 객체 배열
기본 타입 데이터 뿐만 아니라 객체를 원소로 하는 배열도 만들 수 있다. 
이때, 배열의 크기만큼 전부 객채를 하나씩 생성하여 각각 대입해주어야 한다. for문을 사용해 반복하여 하나씩 대입해주면 된다.

## 5. 메소드 활용
메소드 형식, 인자 전달, 메소드 오버로딩에 대해 설명한다.

## Open Challenge
n명이 참가하는 끝말잇기 게임을 만들어보자. 처음 단어는 "아버지"이다. n명의 참가자들은 순서대로 자신의 단어를 입력하면 된다. 끝말잇기에서 끝말이 틀린 경우 게임을 끝내고 게임에서 진 참가자를 화면에 출력한다. 프로그램에서는 시간 지연을 구현하지 않아도 된다. 그렇지만 참가자들이 스스로 시간을 재어보는 것도 좋겠다. 이 문제의 핵심은 여러 개의 객체와 배열 사용을 연습하기 위한 것으로, main()을 포함하는 WordGameApp 클래스와 각 선수를 나타내는 Player 클래스를 작성하고, 실행 중에는 WordGameApp 객체 하나와 선수의 숫자만큼의 Player 객체를 생성하는데 있다. 문제에 충실하게 프로그램을 작성하여야 실력이 늘게 됨을 알기 바란다.

```
끝말잇기 게임을 시작합니다...
게임에 참가하는 인원은 몇명입니까>>3
참가자의 이름을 입력하세요>>황기태
참가자의 이름을 입력하세요>>이재문
참가자의 이름을 입력하세요>>환원선
시작하는 단어는 아버지입니다
황기태>>지우게
이재문>>게다리
한원선>>리본
황기태>>본죽
이재문>>족발
이재문이 졌습니다.
```

> **힌트**
> - WordGameApp, Player의 두 클래스를 작성하는 것을 추천한다. WordGameApp 클래스에는 생성자, main(), 게임을 전체적으로 진행하는 run() 메소드를 둔다. run()에서는 선수 숫자만큼의 Player 객체를 배열로 생성한다.
> - Player 클래스는 게임 참가자의 이름 필드와 사용자로부터 단어를 입력받는 getWordFroUser() 메소드를 두고, WordGameApp 클래스에는 끝말잇기의 성공여부를 판별하는 checkSuccess() 메소드를 두면 좋겠다.
{: .prompt-info}

```java 
import java.util.Scanner;  
  
public class OpenChallenge04 {  
    static Scanner sc = new Scanner(System.in);  
      
    static class WordGameApp {  
        public WordGameApp() {  
            System.out.println("끝말잇기 게임을 시작합니다...");  
        }  
  
        void run() {  
            System.out.print("게임에 참가하는 인원은 몇명입니까>>");  
            int playerNum = sc.nextInt();  
            Player[] players = new Player[playerNum];  
  
            for (int i = 0; i < playerNum; i++) {  
                System.out.print("참가자의 이름을 입력하세요>>");  
                String name = sc.next();  
                players[i] = new Player(name);  
            }  
  
            String formerWord = "아버지"; String word;  
            System.out.println("시작하는 단어는 " + formerWord + "입니다");  
  
            int cnt = 0;  
  
            while (true) {  
                System.out.print(players[cnt].name + ">>");  
                word = players[cnt].getWordFromUser();  
                int lastIndex = formerWord.length() - 1;  
                char lastChar = formerWord.charAt(lastIndex);  
                char firstChar = word.charAt(0);  
                if (!players[cnt].checkSuccess(lastChar, firstChar)) {  
                    break;  
                }  
                formerWord = word;  
                if (cnt == playerNum - 1) cnt = 0;  
                else cnt++;  
            }  
        }  
    }  
  
    static class Player {  
        String name;  
  
        public Player(String name) {  
            this.name = name;  
        }  
  
        String getWordFromUser() {  
            String word = sc.next();  
            return word;  
        }  
  
        boolean checkSuccess(char lastChar, char firstChar) {  
            if (lastChar != firstChar) {  
                System.out.println(this.name + "이(가) 졌습니다.");  
                return false;  
            }  
            return true;  
        }  
    }  
      
    public static void main(String[] args) {  
        WordGameApp app = new WordGameApp();  
        app.run();  
    }  
}
```