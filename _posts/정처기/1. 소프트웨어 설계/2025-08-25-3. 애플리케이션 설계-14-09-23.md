---
layout: post
title: 3. 애플리케이션 설계
date: 2025-08-25 14:09:23 +0900
categories:
  - 정처기
  - 1. 소프트웨어 설계
published: true
tags:
  - 정처기
  - 정보처리기사
---
## 016. 소프트웨어 아키텍처
### 1. 상위 설계와 하위 설계

|       | 상위 설계          | 하위 설계             |
| ----- | -------------- | ----------------- |
| 별칭    | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계      |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위   |
| 세부 목록 | 구조, DB, 인터페이스  | 컴포넌트, 자료 구조, 알고리즘 |

### 2. 모듈화
소프트웨어의 성능을 향상시키거나 시스템 수정, 재사용, 유지 관리 등이 용이하도록 기능을 모듈 단위로 나누는 것.
- 기능의 분리가 가능하여 인터페이스가 단순해짐
- 효율적 관리 가능, 오류의 파급효과 최소화
- 너무 작게 나누면 통합 비용 높아짐, 너무 크게 나누면 단일 비용 높아짐
### 3. 추상화
문제의 개념을 설계 후 구체화 시키는 것.
- 추상화의 유형 - 제과자
	- 과정 추상화
	- 데이터(자료) 추상화
	- 제어 추상화

### 4. 단계적 분해
Niklaus Wirth에 의해 제안된 하향식 설계 전략. 상위 개념을 하위 개념으로 구체화시키는 분할 기법
- 추상화의 반복에 의해 세분화됨
- 상세한건 뒤로 갈 수록 뒤로 미루어 진행

### 5. 정보 은닉
다른 모듈이 접근하지 못하도록 정보와 절차, 자료들을 감춤 = 캡슐화랑 연관
- 필요한 정보만 인터페이스를 통해 주고 받음
- 독립 수행 가능, 다른 모듈 영향 X, 유지보수 쉬움

### 6. 소프트웨어 아키텍처의 품질 속성
시스템, 비즈니스, 아키텍처 측면으로 구성됨

- **시스템 측면**

| 품질 속성  | 내용                       |
| ------ | ------------------------ |
| 성능     | 적절하고 빠르게                 |
| 보안     | 허용되지 않은 접근 차단            |
| 가용성    | 정상적으로 서비스 제공             |
| 기능성    | 만족스럽게 서비스를 제공            |
| 사용성    | 명확하고 편리하게 구현             |
| 변경 용이성 | 다른 플랫폼에서도 동작 가능          |
| 확장성    | 시스템의 용량, 처리능력 확장시 활용 가능  |
| 기타 속성  | 테스트 용이성, 배치성, 안정성 등이 있다. |

**성능** 좋은 폰으로 **변경**해서 용량이 **사기가** **확보**

- **비즈니스 측면**

| 품질 속성     | 내용                              |
| --------- | ------------------------------- |
| 시장 적시성    | 정해진 시간에 프로그램 출시                 |
| 비용과 혜택    | 개발 비용을 높여 유연성이 높은 아키텍처를 만들 것인가? |
| 예상 시스템 수명 | 얼마나 오래 사용할 지                    |
| 기타 속성     | 목표 시장, 공개 일정, 기존 시스템과의 통합 등     |

- **아키텍처 측면**

| 품질 속성    | 내용                              |
| -------- | ------------------------------- |
| 개념적 무결성  | 전체 시스템, 구성요소가 일관성을 유지           |
| 정확성, 완결성 | 제약사항을 완벽하게 모두 충족                |
| 구축 가능성   | 모듈 단위 시스템을 적절히 분배하여 일정 변경 가능하도록 |
| 기타 속성    | 변경성, 시험성, 적응성, 일치성, 대체성 등       |

### 7. 소프트웨어 아키텍처의 설계 과정

1. 설계 목표 설정
2. 시스템 타입 결정
3. 아키텍처 패턴 적용
4. 서브시스템 구체화
5. 검토

> **시스템 타입 / 협약에 의한 설계**
> **시스템 타입**
> - 대화형 (웹 어플리케이션)
> - 이벤트 중심 (전화, 비상벨)
> - 변환형 (컴파일러)
> - 객체 영속형 (데이터베이스)
> **협약에 의한 설계**
> - 선행조건 (오퍼레이션 호출 전)
> - 결과조건 (호출 후)
> - 불변조건 (실행 중)
{: .prompt-info }

## 017. 아키텍처 패턴
### 4. 파이프-필터 패턴
데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송. 앞 시스템의 결과를 파이프로 받아 처리 후 다시 파이프로 다음 시스템에게 건네준다
- 재사용성 좋음, 확장 용이
- 다양한 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
- 데이터 이동 시 오버헤드 발생
- 대표적으로 유닉스의 쉘

### 5. MVC 패턴
- 모델: 서브시스템의 핵심 기능과 데이터 보관
- 뷰: 사용자에게 정보 표시
- 컨트롤러: 사용자의 변경 요청 처리를 위해 모델에게 명령
- 각 부분은 별도의 컴포넌트이므로 서로 영향 받지 않음
- 대화형 애플리케이션에 적합

### 6. 기타 패턴
- 마스터-슬레이브
	- 슬레이브 컴포넌트에서 수행 후 다시 마스터가 돌려받는 방식.
	- 마스터가 모든 작업의 주체, 슬레이브는 결과를 반환
	- 장애 허용 시스템과 병렬 컴퓨팅 시스템에 사용


## 018. 객체지향
### 1. 개요
현실의 개체(엔티티)를 하나의 객체(오브젝트)로 만들어 부품으로 조립하듯 소프트웨어도 객체로 조립하여 작성할 수 있는 기법.

### 2. 객체(오브젝트)
객체는 데이터와 그걸 처리하는 함수를 묶어놓은 하나의 소프트웨어 모듈
- 특성
	- 독립적으로 식별 가능한 이름을 가짐
	- 객체가 가질 수 있는 조건을 상태(State)라고 함. 상태는 시간에 따라 변함
	- 두 객체는 상호 연관성에 의한 관계가 형성됨
	- 객체가 반응할 수 있는 메시지(명령)의 집합을 행위, 객체는 행위의 특징을 나타낼 수 있음
	- 일정한 기억장소를 가짐
- 다른 객체로부터 메시지를 받으면 정해진 기능을 수행함.

### 3. 클래스
공통된 속성과 연산 행위를 갖는 객체의 집합. 객체의 일반적인 타입을 의미.
- 클래스에 속한 각 객체를 **인스턴스**라고 함. 새로운 객체 생성하는 것은 **인스턴스화**라고 한다.

### 4. 캡슐화(Encapsulation)

### 5. 상속(Inheritance)

### 6. 다형성(Polymorphism)

### 7. 연관성(Relationship)

## 019. 객체지향 분석 및 설계

## 020. 모듈

## 021. 공통 모듈

## 022. 코드

## 023. 디자인 패턴