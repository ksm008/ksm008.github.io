---
layout: post
title: 3. 애플리케이션 설계
date: 2025-08-25 14:09:23 +0900
categories:
  - 정처기
  - 1. 소프트웨어 설계
published: true
tags:
  - 정처기
  - 정보처리기사
---
## 016. 소프트웨어 아키텍처
### 1. 상위 설계와 하위 설계

|       | 상위 설계          | 하위 설계             |
| ----- | -------------- | ----------------- |
| 별칭    | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계      |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위   |
| 세부 목록 | 구조, DB, 인터페이스  | 컴포넌트, 자료 구조, 알고리즘 |

### 2. 모듈화
소프트웨어의 성능을 향상시키거나 시스템 수정, 재사용, 유지 관리 등이 용이하도록 기능을 모듈 단위로 나누는 것.
- 기능의 분리가 가능하여 인터페이스가 단순해짐
- 효율적 관리 가능, 오류의 파급효과 최소화
- 너무 작게 나누면 통합 비용 높아짐, 너무 크게 나누면 단일 비용 높아짐
### 3. 추상화
문제의 개념을 설계 후 구체화 시키는 것.
- 추상화의 유형 - 제과자
	- 과정 추상화
	- 데이터(자료) 추상화
	- 제어 추상화

### 4. 단계적 분해
Niklaus Wirth에 의해 제안된 하향식 설계 전략. 상위 개념을 하위 개념으로 구체화시키는 분할 기법
- 추상화의 반복에 의해 세분화됨
- 상세한건 뒤로 갈 수록 뒤로 미루어 진행

### 5. 정보 은닉
다른 모듈이 접근하지 못하도록 정보와 절차, 자료들을 감춤 = 캡슐화랑 연관
- 필요한 정보만 인터페이스를 통해 주고 받음
- 독립 수행 가능, 다른 모듈 영향 X, 유지보수 쉬움

### 6. 소프트웨어 아키텍처의 품질 속성
시스템, 비즈니스, 아키텍처 측면으로 구성됨

- **시스템 측면**

| 품질 속성  | 내용                       |
| ------ | ------------------------ |
| 성능     | 적절하고 빠르게                 |
| 보안     | 허용되지 않은 접근 차단            |
| 가용성    | 정상적으로 서비스 제공             |
| 기능성    | 만족스럽게 서비스를 제공            |
| 사용성    | 명확하고 편리하게 구현             |
| 변경 용이성 | 다른 플랫폼에서도 동작 가능          |
| 확장성    | 시스템의 용량, 처리능력 확장시 활용 가능  |
| 기타 속성  | 테스트 용이성, 배치성, 안정성 등이 있다. |

**성능** 좋은 폰으로 **변경**해서 용량이 **사기가** **확보**

- **비즈니스 측면**

| 품질 속성     | 내용                              |
| --------- | ------------------------------- |
| 시장 적시성    | 정해진 시간에 프로그램 출시                 |
| 비용과 혜택    | 개발 비용을 높여 유연성이 높은 아키텍처를 만들 것인가? |
| 예상 시스템 수명 | 얼마나 오래 사용할 지                    |
| 기타 속성     | 목표 시장, 공개 일정, 기존 시스템과의 통합 등     |

- **아키텍처 측면**

| 품질 속성    | 내용                              |
| -------- | ------------------------------- |
| 개념적 무결성  | 전체 시스템, 구성요소가 일관성을 유지           |
| 정확성, 완결성 | 제약사항을 완벽하게 모두 충족                |
| 구축 가능성   | 모듈 단위 시스템을 적절히 분배하여 일정 변경 가능하도록 |
| 기타 속성    | 변경성, 시험성, 적응성, 일치성, 대체성 등       |

### 7. 소프트웨어 아키텍처의 설계 과정

1. 설계 목표 설정
2. 시스템 타입 결정
3. 아키텍처 패턴 적용
4. 서브시스템 구체화
5. 검토

> **시스템 타입 / 협약에 의한 설계**
> **시스템 타입**
> - 대화형 (웹 어플리케이션)
> - 이벤트 중심 (전화, 비상벨)
> - 변환형 (컴파일러)
> - 객체 영속형 (데이터베이스)
> 
> **협약에 의한 설계**
> - 선행조건 (오퍼레이션 호출 전)
> - 결과조건 (호출 후)
> - 불변조건 (실행 중)
{: .prompt-info }

## 017. 아키텍처 패턴
### 4. 파이프-필터 패턴
데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송. 앞 시스템의 결과를 파이프로 받아 처리 후 다시 파이프로 다음 시스템에게 건네준다
- 재사용성 좋음, 확장 용이
- 다양한 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
- 데이터 이동 시 오버헤드 발생
- 대표적으로 유닉스의 쉘

### 5. MVC 패턴
- 모델: 서브시스템의 핵심 기능과 데이터 보관
- 뷰: 사용자에게 정보 표시
- 컨트롤러: 사용자의 변경 요청 처리를 위해 모델에게 명령
- 각 부분은 별도의 컴포넌트이므로 서로 영향 받지 않음
- 대화형 애플리케이션에 적합

### 6. 기타 패턴
- 마스터-슬레이브
	- 슬레이브 컴포넌트에서 수행 후 다시 마스터가 돌려받는 방식.
	- 마스터가 모든 작업의 주체, 슬레이브는 결과를 반환
	- 장애 허용 시스템과 병렬 컴퓨팅 시스템에 사용


## 018. 객체지향
### 1. 개요
현실의 개체(엔티티)를 하나의 객체(오브젝트)로 만들어 부품으로 조립하듯 소프트웨어도 객체로 조립하여 작성할 수 있는 기법.

### 2. 객체(오브젝트)
객체는 데이터와 그걸 처리하는 함수를 묶어놓은 하나의 소프트웨어 모듈
- 특성
	- 독립적으로 식별 가능한 이름을 가짐
	- 객체가 가질 수 있는 조건을 상태(State)라고 함. 상태는 시간에 따라 변함
	- 두 객체는 상호 연관성에 의한 관계가 형성됨
	- 객체가 반응할 수 있는 메시지(명령)의 집합을 행위, 객체는 행위의 특징을 나타낼 수 있음
	- 일정한 기억장소를 가짐
- 다른 객체로부터 메시지를 받으면 정해진 기능을 수행함.

### 3. 클래스
공통된 속성과 연산 행위를 갖는 객체의 집합. 객체의 일반적인 타입을 의미.
- 클래스에 속한 각 객체를 **인스턴스**라고 함. 새로운 객체 생성하는 것은 **인스턴스화**라고 한다.
- 상위 클래스가 없는건 **최상위 클래스**, 특정 클래스의 부모는 **슈퍼 클래스**, 특정 크래스의 자식은 **서브 클래스**

### 4. 캡슐화(Encapsulation)
데이터와 데이터를 처리하는 함수를 하나로 묶는 것.
- 외부 접근이 제한적이기 때문에 외부 모듈로 인한 파급 효과 적음
- 재사용에 용이
- 인터페이스가 단순해지고 결합도가 낮아짐

### 5. 상속(Inheritance)
상위 클래스의 속성과 연산을 물려받는 것.
- 새로운 속성과 연산을 추가 가능
- 재사용을 높이는 중요한 개념

### 6. 다형성(Polymorphism)
객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각 클래스가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
- 객체들은 동일한 메소드 명 사용, 같은 의미의 응답.
- 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
- 메소드 이름은 같지만 인수를 받는 자료형과 개수를 달리하는 **오버로딩**
- 메소드 이름은 같지만 실행 코드를 달리하는 **오버라이딩**

### 7. 연관성(Relationship)

| 종류             | 의미                                             | 특징                                               |
| -------------- | ---------------------------------------------- | ------------------------------------------------ |
| is member of   | Association(연관화)                               | 2개 이상의 객체가 상호 관련 되어있음                            |
| is instance of | Classfication(분류화)                             | 동일한 형의 특성을 갖는 객체를 모아 구성                          |
| is part of     | aggregation(집단화)                               | 관련있는 객체를 묶어 하나의 상위 객체 구성                         |
| is a           | Generalization / Specialization<br>(일반화 / 특별화) | 공통적인 성질들로 추상화한 상위 객체 구성 / 상위 객체를 구체화하여 하위 객체를 구성 |

## 019. 객체지향 분석 및 설계
### 1. 객체지향 분석의 개념
요구사항을 분석하여 모델링하는 작업
- 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 작업함

### 2. 분석의 방법론
- **Rumbaugh 방법:** 가장 일반적으로 사용되는 방법. 객체, 동적, 기능 모델로 나누어 수행
- **Booch 방법:** 미시적(마이크로) 와 거시적(매크로) 개발 프로세스를 모두 사용하는 분석 방법. 
- **Jacobson 방법:** 유스케이스를 강조하여 사용.
- **Coad-Yourdon 방법:** E-R 다이어그램을 사용
- **Wirfs-Brock 방법:** 분석과 설계 간의 구분이 없고 고객 명세서를 평가.

### 3. 럼바우의 분석기법
모든 소프트웨어 구성요소를 그래픽 표기법으로 사용하여 모델링 하는 기법. 객체 모델링 기법이라고도 함.
- 분석 활동은 **객동기.** 객체 모델링 -> 동적 모델링 -> 기능 모델링 순으로 이루어진다.
- **객체 모델링(Object)**
	- 정보 모델링이라고도 함. 객체 다이어그램으로 표시.
- **동적 모델링(Dynamic)**
	- 상태 다이어그램을 이용. 시간의 흐름에 따른 동작 순서나 상호 작용 등 동적 행위를 표현 
- **기능 모델링(Functional)**
	- 자료 흐름도(DFD)를 사용. 다수 프로세스의 처리 과정을 표현

### 4. 설계지향 원칙

- **단일 책임 원칙(SRP, Single Responsibility Principle)**
	- 객체는 단 하나의 책임만을 가져야한다
	- 응집도는 높고 결합도는 낮아야 함
- **개방-폐쇄 원칙(OCP, Open-Closed Principle)**
	- 기존 코드를 변경하지 않고 기능 추가가 가능해야 한다
	- 공통을 하나의 인터페이스로 캡슐화가 대표적
- **리스코프 치환 원칙(LSP, Liskov Substitution Principle)**
	- 자식 클래스는 부모 클래스가 할 수 있는 행위는 수행가능해야 한다
	- 자식 클래스는 부모의 책임을 무시하지 않고 확장만 수행
- **인터페이스 분리 원칙(ISP, Interface Segregation Principle)**
	- 사용하지 않는 인터페이스와는 관계나 영향을 받으면 안됨
	- 단일 책임 원칙은 객체, 이거는 인터페이스.
- **의존 역전 원칙(DIP, Dependency Inversion Principle)**
	- 추상성이 높은 클래스들과 의존 관계를 맺어야 한다
	- 인터페이스 활용시 이 원칙이 준수됨

## 020. 모듈
### 1. 개요
모듈화를 통해 분리된 시스템들의 기능.
- 독립성이 높아야 한다
- 독립성 기준은 결합도와 응집도로 측정
- 결합도는 낮게, 응집도는 높을수록 좋은 모듈

### 2. 결합도(Coupling)
모듈 간에 상호 의존하는 정도 또는 연관 관계를 의미.
- 결합도가 약할수록 품질이 높다.

자스제외공내 -> 결합 강도 오름차순

**자**주 **스**트레스 받아 **제** 2 **외**국어 **공**부 **내**용을 잊어버린다

- **자료 결합도**
	- 인터페이스가 자료 요소로만 구성됨
- **스탬프 결합도**
	- 인터페이스가 배열이나 레코드 등 자료 구조가 전달될 때
- **제어 결합도**
	- 어떤 모듈이 다른 모듈을 제어하기 위해 신호를 전달함
- **외부 결합도**
	- 어떤 모듈의 변수를 다른 모듈에서 참조할 때
- **공통 결합도**
	- 공통 데이터 영역을 여러 모듈이 사용할 때
- **내용 결합도**
	- 어떤 모듈이 다른 모듈의 내부를 직접 참조하거나 수정

### 3. 응집도(Cohesion)
정보 은닉 개념을 확장한 것. 명령어나 호출문 등 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미.
- 강할수록 품질이 높다.

우논시절교순기 -> 오름차순

### 4. 팬인, 팬아웃
들어오는 놈들이 팬 인, 나가는 놈들이 팬 아웃.



## 021. 공통 모듈

## 022. 코드

## 023. 디자인 패턴