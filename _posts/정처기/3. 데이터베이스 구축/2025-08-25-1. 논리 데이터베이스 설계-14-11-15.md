---
layout: post
title: 1. 논리 데이터베이스 설계
date: 2025-08-25 14:11:16 +0900
categories:
  - 정처기
  - 3. 데이터베이스 구축
published: true
tags:
math: true
---
## 060. 데이터베이스 설계
### 2. 데이터베이스 설계 시 고려 사항

- 무결성
- 일관성
- 회복
- 보안
- 효율성
- 데이터베이스 확장

### 3. 데이터베이스 설계 순서

| 순서       | 내용                       |
| -------- | ------------------------ |
| 요구 조건 분석 | 요구 조건 명세서 작성             |
| 개념적 설계   | 개념 스키마, 트랜잭션 모델링, E-R 모델 |
| 논리적 설계   | 논리 스키마 설계                |
| 물리적 설계   | 물리적 구조의 데이터로 변환          |
| 구현       | DDL로 데이터베이스 / 트랜잭션 생성    |

### 5. 개념적 설계
현실 세계에 대한 인식을 추상적 개념으로.
- 개념 스키마와 트랜잭션 모델링을 병행 수행.
- E-R 다이어 그램 작성, 개념 스키마 설계

### 6. 논리적 설계(데이터 모델링)
현실 세계의 자료를 컴퓨터가 이해할 수 있도록 자료 구조로 변환.
- 관계형 DB라면 테이블을 설계하는 단계.
- 대충 현실, 개념 세계의 데이터를 논리적 구조 데이터로 바꾼다.
- 개념 스키마를 평가, 정제 
- 트랜잭션의 인터페이스를 설계
### 7. 물리적 설계(데이터 구조화)
논리적 데이터를 물리 (디스크) 같은 곳에 저장할 수 있는 물리적 데이터로 변환하는 과정.
- 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정
- 저장 레코드 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법 묘사
- 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간 효율화 등을 고려해야 한다

## 061. 데이터 모델의 개념

### 1. 데이터 모델의 정의
현실의 정보를 컴퓨터에 표현하가 위해 추상적으로 표현한 것.
### 5. 데이터 모델에 표시할 요소
- **구조(Structure):** 논리적으로 표현된 개채 타입 간의 관계. 데이터의 구조와 정적 성질 표현
- **연산(Operation):** 데이터베이스에 저장된 데이터를 처리하는 작업에 대한 명세. 디비를 조작하는 기본 도구
- **제약 조건(Constraint):** 저장될 수 있는 데이터의 제약 조건

## 062. E-R 모델
### 1. E-R 모델의 개요
개념적 데이터의 가장 대표 모델. P. Chen이 제안.
- 개체, 관계, 속성으로 묘사.
- 특정 DBMS를 고려한 것이 아님
- 관계 유형 제한 없이 표현 가능
- 추후 일반화 계층 같은 복잡한 개념이 첨가되어 확장된 모델로 발전함

### 2. E-R 다이어그램
ER 모델을 시각적으로 표현하기 위해 그림으로 표현한 것.

| 기호 이름 | 의미            |
| ----- | ------------- |
| 사각형   | 개체            |
| 마름모   | 관계            |
| 타원    | 속성            |
| 이중 타원 | 다중값 속성        |
| 밑줄 타원 | 기본키 속성        |
| 복수 타원 | 복합 속성         |
| 관계    | 대응수를 선 위에 기술함 |
| 선, 링크 | 개체와 속을 연결     |

### + 관계 표현
관계는 언제나 하나가 되는 개체를 기준으로 잡으면 쉽다. 
ex) 한 도시에는 여러 명의 사람이 살 수 있다. 즉, 도시 쪽 선에 1, 사람 쪽 선에 n을 적으면 된다. 

뭐...아니면... 이런식으로 지문이 나왔다고 치자.
- 사람은 한 도시에 살 수 있다
- 도시에는 여러 사람이 살고 있다
그럼 문장에 나온 첫 개체 뒤 숫자를 보고, 하나인지 다수인지 체크. 해당하는 대응수를 반대 개체쪽에 적어주면 된다... 암튼 쉬움

## 063. 관계형 데이터베이스의 구조
### 2. 관계형 데이터베이스의 릴레이션 구조
릴레이션은 하나의 테이블이다. 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구분됨.

| 학번  | 이름  | 학년  | 신장  | 학과  |
| --- | --- | --- | --- | --- |
| 123 | ㅁㅇㄹ | 1   | 124 | er  |
| 124 | ㄹㅇㅁ | 2   | 124 | re  |
| 125 | ㅈㄷㄱ | 3   | 124 | qw  |

- 여기서 학번, 이름, 학년과 같은 정보들은 **속성 (애트리뷰트)**
- 그리고 각 속성들이 가질 수 있는 값들은 **도메인** 
- 하나의 행을 **튜플**
- 그리고 여기서 데이터가 들어있는 곳들을 **릴레이션 인스턴스**
- 속성들의 집합을 **릴레이션 스키마**

이 모든 것을 합쳐서 **릴레이션**이라고 한다.

- 튜플의 수는 **카디널리티**
- 속성의 수는 **Degree** 또는 **차수**
- 도메인은 하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합.
ex) 성별 애트리뷰트의 도메인은 남/여. 그 외는 입력 불가

### 3. 릴레이션의 특징
- 한 릴레이션에는 똑같은 튜플 포함 불가
- 튜플에는 순서가 없음
- 릴레이션은 튜플의 삽입, 삭제로 계속 변함
- 속성 간 순서는 중요하지 않음
- 속성의 명칭은 달라야 하지만, 구성하는 값은 동일할 수 있음
- 속성의 부분 집합을 키로 설정하여 튜플을 유일하게 식별
- 속성은 더는 안쪼개지는 원자값만을 저장

## 064. 관계형 디비의 제약 조건 - 키
### 1. 키가 머임?
튜플을 찾기 위한 기준 속성임
종류는 후보 키, 기본 키, 대체 키, 슈퍼 키, 외래 키가 있음

### 2. 후보키(Candidate Key)
기본키로 사용이 가능한 속성들을 말함.
- 모든 릴레이션에는 하나 이상의 후보키가 존재함. (왜냐면 기본키도 후보키에서 온 것이기 때문)
- 후보키는 모든 튜플에 대해 유일성, 최소성을 만족해야함.
	- **유일성:** 하나의 키 값으로 하나의 튜플을 유일하게 식별 가능해야함
	- **최소성:** 모든 레코드를 식별하는데 꼭 필요한 속성으로만.

### 3. 기본키(Primary Key)
후보키 중 선정된 주키. 중복된 값을 가질 수 없음
- 특정 튜플을 유일하게 구별할 수 있는 속성
- 후보키의 성질을 가짐.
- 기본키는 NULL 값을 가질 수 없음.

### 4. 대체키(Alternate Key)
후보키가 둘 이상일때, 기본키를 제외한 나머지 키

### 5. 슈퍼키(Super Key)
한 릴레이션 내의 속성들의 집합으로 구성된 키. 
여러 속성들로 합쳐져있기 때문에 최소성은 만족시키지 못하고, 유일성만 만족시킴.
ex) 학번 + 주민번호 같은 형태

### 6. 외래키(Forigen Key)
다른 테이블의 기본키를 참조하는 속성을 말함. 
- 다른 테이블의 기본키와 대응되기 때문에 릴레이션 간의 참조 관계를 표현하는데 중요함.
- 외래키로 지정되면 참조하는 릴레이션의 기본키에 없는 값은 입력 불가.

## 065. 관계형 디비의 제약 조건 - 무결성
### 1. 무결성이란
디비에 저장된 값과 현실 세계의 값이 일치하는 정확성을 의미.
- 디비 안 데이터의 정확성을 보장하기 위한 제약 조건임.

### 2. 엔티티 무결성 (개체 무결성)
기본키는 NULL이나 중복 값을 가질 수 없다
### 3. 도메인 무결성
속성 값은 정의된 도메인에 속한 값이어야 함
### 4. 참조 무결성
외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 같아야 한다. 
### 5. 사용자 정의 무결성
나머지는 사용자가 정의한 제약 조건을 만족해야 한다는 것.

## 066. 관계대수 및 관계해석
### 1. 관계대수의 개요
관계디비에서 원하는 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어.
- 연산자와 연산규칙을 사용함. 피연산자도 릴레이션, 결과도 릴레이션.
- 수행해야할 연산의 순서를 명시한다.
- 순수 관계 연산자와 일반 집합 연산자가 있다.
	- **순수 관계 연산자:** Select, Project, Join, Division
	- **일반 집합 연산자:** UNION(합집합), INSERSECTION(교집합), DIFFERENCE(차집합), CARTIESIAN PRODUCT(교차곱)


### 2. Select
선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듬.

그리스 문자 시그마(σ) 사용<br>$$σ_<조건>R $$
조건에서는 비교 연산이 허용됨. 또는 논리 연산자를 사용하여 하나의 조건으로 결합도 가능.

### 3. Project
제시된 속성 값들만 추출. 속성을 추출하는 것이므로 수직 연산자라고도 한다.

그리스 문자 파이(π) 사용<br>$$π_<속성리스트>R$$
### 4. Join
공통 속성을 중심으로 두 릴레이션을 합쳐 새로운 릴레이션을 만듬.
- 결과 릴레이션의 차수는 조인된 두 릴레이션의 차수를 더한것과 같다.
- 카티션 프로더트(교차곱)를 수행 후 셀렉트를 수행한 것과 같다.
- 기호는 _▷◁_ 사용
- 그냥 두 테이블을 붙였다라고 생각하면 됨<br>$$R▷◁_(키속성r=키속성s)S$$

### 5.  Division
특정 릴레이션이 가진 속성만 제외한 속성을 구하는 연산.
- 기호는 나눗셈.<br>$$R[속성r ÷ 속성s] S$$
- 속성 r은 릴레이션 r의 속성, s는 릴레이션 s의 속성. 여기서 두 속성은 동일 값을 가져야 한다.

### 6. 일반 집합 연산자


| 연산자                             | 기능 및 수학적 표현    | 카디널리티 |
| ------------------------------- | -------------- | ----- |
| 합집합<br>(UNION)<br>⋃             | 합집합하세요         | 안     |
| 교집합<br>(INTERSECTION)<br>⋂      | 교집합하세요         | 중     |
| 차집합<br>(DIFFERENCE)<br>-        | 차집합하세요         | 요     |
| 교차곱<br>(CARTESIAN PRODUCT)<br>X | 튜플에 있는 순서쌍 구하기 | 해     |

### 7. 관계해석
관계 데이터의 연산을 해석하는 방법. 
- 수학의 프레디킷 해석에 기반을 두고 있으며 비절차적 특성을 지닌다.
- 튜플 관계해석과 도메인 관계해석이 있다.
- ∀ (전칭 정랑자): 가능한 모든 튜플에 대하여 (FOR ALL)
- ∃ (존재 전랑자): 하나라도 일치하는 튜플이 있음 (THERE EXIST)

## 067. 정규화
### 1. 정규화란
함수의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 것.
- 논리적 설계 단계에서 수행
- 논리적 처리와 품질에 큰 영향을 미침
- 정규화된 데이터는 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장.
- 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 정확성이 높지만 물리적 접근이 복잡해지고 많은 조인 연산으로 조회 성능이 저하됨.

### 2. 정규화의 목적
대충 좋은거 판별하면 됨

### 4. 아노말리(이상)의 개념 및 종류
정규화를 거치지 않으면 아노말리가 생긴다. 종류는 삽입, 삭제, 갱신이 있다.
- 삽입 이상: 원하지 않는 값도 함께 삽입될 때
- 삭제 이상: 상관없는 값도 함께 삭제될 때
- 갱신 이상: 일부 값들만 변경되어 정보에 모순이 생길 때
### 5. 정규화 과정

**도부이결다조** -> **도**메인, **부**분 함수 종속, **이**행 함수 종속, **결**정자 후보키, **다**치 종속 제거, **조**인 종속성 이용

**1NF(제1정규형)**
모든 도메인이 원자값으로만 되어있다.

**2NF(제2정규형)**
1정규형을 만족하면서 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족 (부분 함수 종속 제거)

**3NF(제3정규형)**
이행적 함수 종속을 제거

**BCNF(BOYCE-CODD 정규형)**
결정자이면서 후보키가 아닌 것을 제거

**4NF(제4정규형)**
다치 종속 제거

**5NF(제5정규형)**
조인 종속성 이용 = 후보키를 통하지 않는 조인 종속 제거 = 후보키를 통한 조인 종속만 성립

## 068. 반정규화
### 1. 반정규화란
시스템의 성능 향상을 위해 의도적으로 정규화 원칙을 위배하는 행위.
- 너무 심하게 하면 안좋대요
- 적당히 성능을 올리는 선에서만
- 데이터 우선인지, 성능 우선인지 정해야함
- 방법으로는 테이블 통합 / 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다.
### 2. 테이블 통합
만약 두 테이블 조인이 너무 잦다면 그냥 애초에 합쳐두면 편하다.
- 테이블 통합 종류로는 1:1 관계 타입, 1:N, 슈퍼타입, 서브타입이 있다.
- 검색은 쉽지만 처리량이 증가하고 수정이 복잡해진다.
- 낫 널, 디폴트, 체크 등 제약조건 설계가 어려워짐

### 3. 테이블 분할
테이블을 수직이나 수평으로 분할하는 것.

### 4. 중복 테이블 추가
여러 테이블에서 데이터를 추출하거나 다른 서버에 저장된 테이블을 사용해야 하는 경우 중복 테이블을 추가.
- 정규화로 인해 속도가 느려지거나
- 특정 범위나 많은 범위의 데이터를 자주 처리해야 하거나
- 범위를 줄이지 않으면 속도가 개선되지 않는 경우
- 방법은 다음과 같다
	- 집계 테이블의 추가
	- 진행 테이블의 추가
	- 특정 부분만을 포함하는 테이블의 추가

### 5. 중복 속성 추가
조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것

## 069. 시스템 카탈로그
### 1. 시스템 카탈로그의 의미
시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 가진 시스템 디비.
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 카탈로그를 데이터 사전이라고도 한다. (Data Dictionary)
- 데이터 객체에 대한 정의나 명세에 관한 정보를 유지관리하는 시스템 테이블.

### 2. 시스템 카탈로그 저장 정보
카탈로그에 저장되는 정보들을 메타 데이터라고 한다. 다음과 같은 유형의 데이터가 저장된다.
- 데이터베이스 객체 정보: 테이블, 인덱스, 뷰 등 구조나 통계
- 사용자 정보
- 무결성 제약 조건 정보
- 함수, 프로시저, 트리거 등에 대한 정보
### 3. 카탈로그의 특징
- 카탈로그는 시스템 테이블로 구성되어있어 일반 이용자도 SQL을 이용하여 내용을 검색 가능
- DML (insert 같은거)로 카탈로그 갱신은 불가
- 디비 시스템에 따라 다르고 DBMS가 자체 생성 및 유지함.