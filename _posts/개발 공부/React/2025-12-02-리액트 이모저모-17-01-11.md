---
layout: post
title: 리액트 이모저모
date: 2025-12-02 17:01:11 +0900
categories:
  - React
published: true
math: true
tags:
  - React
---
## # useState

리액트는 화면을 직접 조작하는 대신 상태라는 데이터를 관리한다. 이 데이터가 바뀌면 리액트가 알아서 화면을 새로 그려준다.

```jsx
import React, { useState } from 'react'; // 1. import 필수!

function Counter() {
  // 2. useState 호출
  // [현재 상태 값, 상태를 변경하는 함수] = useState(초기값);
  const [count, setCount] = useState(0); 

  const handleClick = () => {
    // 3. 반드시 setCount 함수를 통해 상태를 변경해야 함!
    // count = count + 1; // ❌ 이렇게 직접 변경하면 안 됨. 화면 갱신 안 됨.
    setCount(count + 1); 
  };

  return (
    <div>
      <p>현재 값: {count}</p>
      <button onClick={handleClick}>증가</button>
    </div>
  );
}
```

useState(0) 함수를 실행하면 리액트는 2칸짜리 배열을 뱉어낸다. 0번 칸에는 현재 상태 값을, 1번 칸은 상태를 바꿀 수 있는 함수 (세터 함수)를 뱉어낸다.

근데 const는 상수이다. 상수는 값을 변경할 수 없는데 어떻게 세터 함수로 값을 변경시킨다는 것일까? 바로 값을 변경시키는 것이 아니라, 새로운 상수로 선언시키는 것이다. 변수 자체가 바뀌는 것이 아닌, 매번 새로운 상수가 갈아끼워진다.

렌더링 원리는 아래와 같다.

1. setCount(1)을 호출.
2. 리액트는 데이터가 바뀐 것을 보고 화면을 다시 그림.
3. App 함수를 다시 처음부터 실행.
4. 다시 실행될 때 useState(1)이 실행되며 새로운 const count가 1로 선언됨.

let으로는 화면이 바뀌지 않는다. 또한 자바와 달리 state 선언시 사용된 다른 자료형도 세터로 설정이 가능하다. 만약 타입스크립트를 쓴다면 자바와 같이 제네릭 문법을 사용하여 `useState<Number>(0)`과 같은 형태로 자료형을 강제할 수 있다.

## # useEffect

컴포넌트가 태어날 때, 업데이트될 때, 사라질 때 특정 작업을 수행하도록 한다. 만약 백엔드 서버에서 데이터를 가져올 때 (Fetch) 이 Hook이 필수적으로 사용된다.

useEffect를 이해하려면 Side Effect (부수 효과)라는 개념을 알아야 한다.

1. 순수 함수: 입력이 같으면 출력이 항상 같다. (int sum(a, b) 처럼 입력값만 계산하는 함수)
2. 부수 효과: 함수가 실행될 때 함수 외부의 세상에 영향을 주거나 외부로부터 영향을 받는 모든 행위 
	1. 함수가 전역 변수를 변경
	2. 로그를 출력
	3. 데이터베이스에 저장하거나 API를 호출
	4. DOM 조작 (브라우저의 탭 제목을 바꾸는 등)
	5. 서버 통신 (GET 요청)
	6. 브라우저 저장소 (쿠키/스토리지에 저장)

```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState([]);
  
  // 첫 번째 인자: 실행할 함수 (Side Effect)
  // 두 번째 인자: 의존성 배열 (Dependency Array)
  useEffect(() => {
    // 💡 여기가 네가 아까 수정했던 비동기 통신 코드가 들어갈 자리야!
    
    // 1. 컴포넌트가 화면에 처음 나타났을 때만 실행 (마운트 시)
    fetch('/api/posts').then(res => res.json()).then(setData);

  }, []); // 배열이 비어 있으면 (Mount 시) 단 한 번만 실행

  return (
      <div>{data.map(item => <p key={item.id}>{item.title}</p>)}</div>
  );
}
```

useEffect는 딱 2가지 인자를 받는다.

```jsx
useEffect(실행할 함수, 의존성 배열)
```

1. 실행할 함수 : 부수효과 등을 넣을 코드 블록
2. **의존성 배열** : useEffect가 언제 다시 실행될 지를 결정하는 배열이다. 여기에 어떤 값을 넣느냐에 따라 동작 방식이 달라지므로 useEffect의 핵심이다.

의존성 배열에 무엇을 넣느냐에 따라 컴포넌트의 생명주기를 제어할 수 있다.


1. 배열이 비어있는 경우

```jsx
useEffect(() => {
  // 백엔드 API 호출, 구독 이벤트 등록 등
  console.log("컴포넌트가 처음 화면에 나타났을 때만 (Mount) 실행됨.");
}, []); // 👈 배열이 비어 있음
```

실행 시점은 컴포넌트가 처음 화면에 렌더링 된 직후에 딱 한 번만 실행된다. 주로 초기 데이터를 로딩하거나 (백엔드 GET 요청) 외부 이벤트 등록에 사용된다.

2. 배열 생략

```jsx
useEffect(() => {
  console.log("렌더링될 때마다 매번 실행됨.");
}); // 👈 배열이 아예 없음
```

useState나 props가 바뀔 때마다, 즉 컴포넌트가 새로 그려질 때마다 매번 실행된다.

3. 배열에 값이 들어있는 경우

```jsx
useEffect(() => {
  console.log(keyword + "가 변경되었습니다. 새 데이터 요청!");
  // 새로운 검색 결과 요청 API
}, [keyword]); // 👈 배열 안에 keyword가 들어 있음
```

컴포넌트가 렌더링 될 때 배열 안의 값이 이전과 다르다면 실행된다. 검색어, 페이지 번호, 필터 등 특정 상태가 바뀔때만 데이터를 갱신할 때 사용된다.

## # Props

Props는 컴포넌트끼리 소통하는 유일한 방법으로 자바의 메소드 파라미터랑 같다. 

```jsx
// Parent.jsx
import Child from './Child';

function Parent() {
  const myName = "제미나이";
  
  return (
    <div>
      {/* 1. 문자열은 그냥 따옴표 "" */}
      <Child title="안녕하세요" />
      
      {/* 2. 변수나 숫자는 중괄호 {} */}
      <Child name={myName} age={20} />
    </div>
  );
}
```

1. 호출하는 쪽에는 이름={값} 형태로 넣어주면 된다.

```jsx
// Child.jsx
// 중괄호 {}를 써서 필요한 것만 쏙쏙 뽑아냄
function Child({ title, name, age }) {
  return (
    <div>
      <h1>{title}</h1>
      <p>이름: {name}</p>
      <p>나이: {age}</p>
    </div>
  );
}
```

2. 받는 쪽에서는 내용물만 변수로 받는다. 또한 함수 선언부에서 기본값을 정해줄 수도 있다.

```jsx
// Child.jsx
// 값이 안 들어오면 "이름 없음", 0을 대신 쓴다!
function Child({ title, name = "이름 없음", age = 0 }) {
  return (
    <div>
      <h1>{title}</h1>
      <p>이름: {name}</p>
      <p>나이: {age}세</p>
    </div>
  );
}
```

Props는 읽기 전용이므로 건네준 데이터를 마음대로 바꿀 수 없다. 만약 바꾸고 싶다면 바꿔달라는 요청을 이벤트로 해야 한다.

## # 애로우 펑션

### 기본 구조

function 키워드를 없애고 화살표를 사용하는 함수. 반환값이 있다면 return 키워드를 쓰면 되고 void면 생략한다 (return undefined와 동일). 

```jsx
const sum = (a , b) => {return a + b};
```

### 암시적 반환

애로우 함수는 본문이 딱 한 줄의 표현식일 때, 중괄호와 return 키워드를 생략 가능.

```jsx
const add = (a , b) => a + b;
```

### JSX 코드 반환

JSX코드도 하나의 표현식이기 때문에 소괄호로 감싸 암시적으로 반환 가능.

```jsx
const MyComponent = () => (
  <div>
    <h1>Hello, React!</h1>
  </div>
);
```

### JSX 활용 패턴 2가지
#### 1. 이벤트 핸들러
버튼을 클릭했을 때 특정 함수를 실행시키고 싶을 때 쓰인다. 특히 함수에 데이터를 넘겨줘야 할 때 필수적으로 사용됨.

- **패턴 1: 인자 없이 함수를 호출**

```jsx
const handleClick = () => {
  console.log('버튼 클릭됨');
};

<button onClick={handleClick}>클릭하세요</button>
```

- **패턴 2: 인자를 전달하며 함수를 호출**

함수를 호출하는 코드를 애로우 함수로 한 번에 감싸서 전달. 이렇게 하지 않으면 컴포넌트가 렌더링 되는 순간 함수가 바로 실행된다.

```jsx
const handleDelete = (postId) => {
  console.log(`${postId}번 게시글 삭제`);
};

// 나쁜 예: 랜더링 시 즉시 호출됨
// <button onClick={handleDelete(10)}>삭제</button> 

// 좋은 예: 클릭 시에만 함수 실행
<button onClick={() => handleDelete(10)}>삭제</button>
```

#### 2. 리스트 렌더링

JSX 안에서 배열 데이터를 화면에 뿌릴 때 map 함수를 쓴다. 이때 콜백 함수로 애로우 함수가 사용된다.

```jsx
function PostList({ posts, onSelectPost }) {
  return (
    <ul>
      {posts.map((post) => (
        // map의 콜백 함수로 애로우 함수 사용 (암시적 반환)
        // post 객체를 받아서 <li> 태그를 반환함
        <li key={post.id} onClick={() => onSelectPost(post.id)}>
          {post.title}
        </li>
      ))}
    </ul>
  );
}
```

## # JSX에서의 this

자바에서의 this는 **이 메소드를 가지고 있는 인스턴스 자기 자신**이다. 누가, 어디서 호출하든 this는 항상 그 객체를 가리키며 절대 변하지 않는다.

```java
class User {
    String name = "Kim";
    
    void printName() {
        System.out.println(this.name); // this는 무조건 User 인스턴스!
    }
}
```

하지만 자바스크립트의 일반 함수 this는 누가 자신을 호출했는가에 따라 계속 바뀐다.

```jsx
const user = {
  name: "Kim",
  printName: function() {
    console.log(this.name);
  }
};

user.printName(); // 1. user가 호출함 -> this는 user (Kim 출력)

const myFunc = user.printName; 
myFunc(); // 2. 그냥 호출함 -> this는 전역 객체(window)나 undefined가 돼버림! (에러 발생)
```

애로우 함수는 this 키워드를 아예 가지고 있지 않다.  그래서 자신이 생성된 곳의 this를 그대로 물려받는다. 이를 렉시컬 스코프 (Lexical Scope) 따라서 애로우 함수의 this는 자신이 작성된 곳의 this를 그대로 쓴다. 여기서 작성된 곳의 기준은 상위 스코프, 즉 함수나 전역을 의미한다. 객체는 스코프가 될 수 없다.

```jsx
// App 컴포넌트 (함수!) - 여기가 울타리가 됨
function App() {
  const title = "리액트 게시판";

  // 화살표 함수
  const handleClick = () => {
    // 이 화살표 함수는 자신이 태어난 곳(App 함수 내부)을 쳐다봄.
    // 그래서 App의 변수나 상태에 안전하게 접근 가능!
    console.log(title); 
  };

  return <button onClick={handleClick}>클릭</button>;
}
```

## # 비동기

자바 스크립트는 싱글 스레드 기반이기 때문에 비동기 처리가 필수적이다.

1. 동기 : 순차적으로 진행한다. 앞의 일이 끝나야 다음 일을 한다. 
2. 비동기 : 오래 걸리는 일은 잠시 맡기고 다음 일부터 한다. 서버 통신이나 타이머 같이 오래 걸리는 작업을 만나면 나중에 알려달라 부탁하고 다음 줄로 넘어간다.

```jsx
console.log("1. 주문 받기");

// 비동기 함수 (오래 걸리는 작업)
setTimeout(() => {
  console.log("2. 커피 만들기 완료 (3초 뒤)");
}, 3000);

console.log("3. 다른 손님 받기 (바로 실행)");

// [실행 결과]
// 1. 주문 받기
// 3. 다른 손님 받기
// (3초 뒤) -> 2. 커피 만들기 완료
```

예전에는 Promise와 .then()을 썼지만 최근에는 async / await을 표준으로 쓴다.

- async: 함수 안에 비동기 작업이 있음을 선언
- await: 비동기 작업이 끝날때까지 기다림을 명령 (다른 UI는 멈추지 않는다)

```jsx
// 자바 개발자가 보기 편한 방식 (async/await)
const getPost = async () => {
  console.log("데이터 요청 시작");
  
  // await가 없으면 데이터를 받아오기도 전에 다음 줄로 넘어가서 에러 남!
  // await를 쓰면 여기서 응답이 올 때까지 기다려줌 (단, 브라우저는 안 멈춤)
  const response = await fetch('/api/posts'); 
  const data = await response.json();
  
  console.log("데이터 도착:", data);
};
```

또한 useEffect의 첫 번째 인자인 함수에는 async를 직접적으로 붙일 수 없다. 때문에 안에서 함수를 하나 만들어서 호출해야 한다.

```jsx
// ❌ 나쁜 예 (에러 발생 혹은 오동작)
useEffect(async () => { 
  const data = await fetch('/api'); 
}, []);

// ✅ 좋은 예 (안에서 함수를 만들어서 호출)
useEffect(() => {
  const fetchData = async () => {
    const res = await fetch('/api');
    const json = await res.json();
    setData(json);
  };
  
  fetchData(); // 만든 함수 실행
}, []);
```

참고로 함수 앞에 async가 붙어있다면 return이 없어도 Promise 객체가 반환된다.