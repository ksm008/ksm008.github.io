---
layout: post
title: 리액트 이모저모
date: 2025-12-02 17:01:11 +0900
categories:
  - React
published: true
math: true
tags:
  - React
---
## # useState

리액트는 화면을 직접 조작하는 대신 상태라는 데이터를 관리한다. 이 데이터가 바뀌면 리액트가 알아서 화면을 새로 그려준다.

```jsx
import React, { useState } from 'react'; // 1. import 필수!

function Counter() {
  // 2. useState 호출
  // [현재 상태 값, 상태를 변경하는 함수] = useState(초기값);
  const [count, setCount] = useState(0); 

  const handleClick = () => {
    // 3. 반드시 setCount 함수를 통해 상태를 변경해야 함!
    // count = count + 1; // ❌ 이렇게 직접 변경하면 안 됨. 화면 갱신 안 됨.
    setCount(count + 1); 
  };

  return (
    <div>
      <p>현재 값: {count}</p>
      <button onClick={handleClick}>증가</button>
    </div>
  );
}
```

useState(0) 함수를 실행하면 리액트는 2칸짜리 배열을 뱉어낸다. 0번 칸에는 현재 상태 값을, 1번 칸은 상태를 바꿀 수 있는 함수 (세터 함수)를 뱉어낸다.



## # useEffect

컴포넌트가 태어날 때, 업데이트될 때, 사라질 때 특정 작업을 수행하도록 한다. 만약 백엔드 서버에서 데이터를 가져올 때 (Fetch) 이 Hook이 팔수적으로 사용된다.

```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState([]);
  
  // 첫 번째 인자: 실행할 함수 (Side Effect)
  // 두 번째 인자: 의존성 배열 (Dependency Array)
  useEffect(() => {
    // 💡 여기가 네가 아까 수정했던 비동기 통신 코드가 들어갈 자리야!
    
    // 1. 컴포넌트가 화면에 처음 나타났을 때만 실행 (마운트 시)
    fetch('/api/posts').then(res => res.json()).then(setData);

  }, []); // 배열이 비어 있으면 (Mount 시) 단 한 번만 실행

  return (
      <div>{data.map(item => <p key={item.id}>{item.title}</p>)}</div>
  );
}
```

## # Props

## # 애로우 펑션

### 기본 구조

function 키워드를 없애고 화살표를 사용하는 함수.

```jsx
const sum = (a , b) => {return a + b};
```

### 암시적 반환

애로우 함수는 본문이 딱 한 줄의 표현식일 때, 중괄호와 return 키워드를 생략 가능.

```jsx
const add = (a , b) => a + b;
```

### JSX 코드 반환

JSX코드도 하나의 표현식이기 때문에 소괄호로 감싸 암시적으로 반환 가능.

```jsx
const MyComponent = () => (
  <div>
    <h1>Hello, React!</h1>
  </div>
);
```

### JSX 활용 패턴 2가지
#### 1. 이벤트 핸들러
버튼을 클릭했을 때 특정 함수를 실행시키고 싶을 때 쓰인다. 특히 함수에 데이터를 넘겨줘야 할 때 필수적으로 사용됨.

- **패턴 1: 인자 없이 함수를 호출**

```jsx
const handleClick = () => {
  console.log('버튼 클릭됨');
};

<button onClick={handleClick}>클릭하세요</button>
```

- **패턴 2: 인자를 전달하며 함수를 호출**

함수를 호출하는 코드를 애로우 함수로 한 번에 감싸서 전달. 이렇게 하지 않으면 컴포넌트가 렌더링 되는 순간 함수가 바로 실행된다.

```jsx
const handleDelete = (postId) => {
  console.log(`${postId}번 게시글 삭제`);
};

// 나쁜 예: 랜더링 시 즉시 호출됨
// <button onClick={handleDelete(10)}>삭제</button> 

// 좋은 예: 클릭 시에만 함수 실행
<button onClick={() => handleDelete(10)}>삭제</button>
```

#### 2. 리스트 렌더링

JSX 안에서 배열 데이터를 화면에 뿌릴 때 map 함수를 쓴다. 이때 콜백 함수로 애로우 함수가 사용된다.

```jsx
function PostList({ posts, onSelectPost }) {
  return (
    <ul>
      {posts.map((post) => (
        // map의 콜백 함수로 애로우 함수 사용 (암시적 반환)
        // post 객체를 받아서 <li> 태그를 반환함
        <li key={post.id} onClick={() => onSelectPost(post.id)}>
          {post.title}
        </li>
      ))}
    </ul>
  );
}
```

## # JSX에서의 this

자바에서의 this는 **이 메소드를 가지고 있는 인스턴스 자기 자신**이다. 누가, 어디서 호출하든 this는 항상 그 객체를 가리키며 절대 변하지 않는다.

```java
class User {
    String name = "Kim";
    
    void printName() {
        System.out.println(this.name); // this는 무조건 User 인스턴스!
    }
}
```

하지만 자바스크립트의 일반 함수 this는 누가 자신을 호출했는가에 따라 계속 바뀐다.

```jsx
const user = {
  name: "Kim",
  printName: function() {
    console.log(this.name);
  }
};

user.printName(); // 1. user가 호출함 -> this는 user (Kim 출력)

const myFunc = user.printName; 
myFunc(); // 2. 그냥 호출함 -> this는 전역 객체(window)나 undefined가 돼버림! (에러 발생)
```

애로우 함수는 this 키워드를 아예 가지고 있지 않다.  그래서 자신이 생성된 곳의 this를 그대로 물려받는다. 이를 렉시컬 스코프 (Lexical Scope) 따라서 애로우 함수의 this는 자신이 작성된 곳의 this를 그대로 쓴다. 여기서 작성된 곳의 기준은 상위 스코프, 즉 함수나 전역을 의미한다. 객체는 스코프가 될 수 없다.

```jsx
// App 컴포넌트 (함수!) - 여기가 울타리가 됨
function App() {
  const title = "리액트 게시판";

  // 화살표 함수
  const handleClick = () => {
    // 이 화살표 함수는 자신이 태어난 곳(App 함수 내부)을 쳐다봄.
    // 그래서 App의 변수나 상태에 안전하게 접근 가능!
    console.log(title); 
  };

  return <button onClick={handleClick}>클릭</button>;
}
```



