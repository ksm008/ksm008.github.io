---
layout: post
title: 1-2. 리눅스의 기초
date: 2025-12-17 17:24:24 +0900
categories:
  - 리눅스마스터 1급
  - 1. 리눅스 실무의 이해
published: true
math: true
tags:
  - 리눅스마스터
---
## 1. 리눅스 개요
### 1. 리눅스의 정의 및 의미
#### 1. 리눅스의 정의
- 대충 리누스 토발즈가 개발...오픈소스... PC, 서버, 메인 프레임, 모바일 기기, 임베디드 기기를 위한 유닉스 호환 운영체제라는 따분한 이야기

#### 2. 리눅스의 의미
- 리눅스가 처음 개발된 당시에는 단지 리눅스 커널만을 의미했다. (현재는 파일, 네트워크, X Window, 개발자 도구 등 다양한 패지키를 포함하는 운영체제의 형태)
- 현재는 FSF(Free Software Foundation)가 GNU 프로젝트를 통해 리눅스 커널 기반으로 다양한 라이브러리와 애플리케이션이 포함된 배포판을 제공하고 있으며, 이를 강조하고자 GNU/Linux라고도 부른다.

### 2. 리눅스의 일반적 특징
#### 1. 이식성
- 최소한의 플랫폼에 종속적인 부분만 어셈블리어로 작성됨, 대부분의 코드가 C언어로 작성됨 - 다양한 하드웨어에 쉽게 이식이 가능함. 
- 처음에는 인텔 x86 CPU를 기본 지원 - 이후 여러 CPU 아키텍처에 적용되고 있음

#### 2. 자유 소프트웨어
- 리눅스는 단일 기업에 의해 운영되는 것이 아니라 전세계 개발자들의 기여를 통해 진화하는 중
- 리눅스의 소스코드는 자유롭게 사용, 수정, 배포가 가능. 하지만 수정된 프로그램의 복사본은 소스코드와 함께 배포되어야 함.
- 리눅스의 소프트웨어들은 상당수 GPL(General Purose License)이나 LGPL(Library/Lesser General Purpose License) 라이선스를 따른다.

#### 3. 멀티 유저
- 다수의 사용자가 네트워크를 통하여 한 시스템의 CPU, 메모리, 저장소 등의 자원에 접근하고 사용할 수 있다.

#### 4. 멀티 프로그래밍
- 다수의 프로그램을 메모리에 적재하고 동시에 실행 가능하다.

#### 5. 계층적 파일 시스템
- 리눅스는 시스템과 사용자를 위한 표준화된 디렉터리 구조를 정의함.
- 예를 들어, 장치 관련은 /dev에 위치하고 사용자를 위한 파일은 /usr 이하에 위치한다.

#### 6. 셸
- 리눅스에서 다양한 기능을 수행할 수 있도록 명령어 기반 프로그램을 제공함. 사용자는 이 프로그램을 통하여 커널에게 명령을 내리고 셸은 명령어를 해석하여 그에 맞는 프로그램을 실행한다.

#### 7. 보안
- 유닉스의 보안 모델을 이어받아 임의접근제어(DAC)를 제공하고, 이를 향상한 확장한 임의접근제어(Extended DAC) 또한 제공한다.
- 리눅스는 네트워크 정책에 따라서 네트워크 상의 노드나 라우터로 동작할 수 있으며 네트워크 인터페이스에서 발생한 트래픽을 서버로 안전하게 전달할 수 있다. 이를 위해 netfiler, iptabels, ebtables, arptables 등의 모듈을 제공한다.
- 네트워크 스택은 IPSec을 제공하여 IP 통신할 떄 안전하게 데이터를 송수신할 수 있다.
- 강제접근제어(MAC)를 강화한 SETLinux가 존재한다.

### 3. 리눅스의 기술적 특징
#### 1. 모놀리딕 커널
- 운영체제가 제공하는 서비스를 하나의 커널로 제공하는 방식. (파일 시스템, 프로세스 간 통신, 입출력 기능... 등등)
- 단일 커널로 운영체제의 기능이 제공되기 때문에 커널에 포함된 일부 기능을 변경하려면 커널을 다시 컴파일해야한다.
- 리눅스는 기본적으로 모놀리딕 커널. 하지만 동적 로드가 가능한 커널 모듈과 동적 설정을 위한 프로퍼티 기능 제공으 통해 커널의 유연성을 확보하고 있다.

#### 2. 장치의 파일화
- 리눅스는 시스템의 자원을 모두 파일로 다룬다. 파일은 디렉터리, 일반 파일, 특수 파일로 나눌 수 있다. 
- 장치의 유형에 따라 문자 장치 파일과 블록 장치 파일과 같은 장치 파일을 제공한다.
- 프로세스 간 통신을 위한 파이프 파일, 응용 프로그램의 소켓 프로그래밍 지원을 위한 소켓 파일을 제공함.

#### 3. 다양한 파일 시스템의 지원
- ext2, ext3, ext4와 같은 리눅스 자체 파일 시스템을 제공한다.
- FAT32, NTFS같은 윈도우용 파일 시스템도 제공하며, 네트워크 파일 시스템은 SMB, CIFS의 파일 시스템도 지원함.
- 시스템 충돌이나 전원 문제가 생겼을 때 복구 가능한 저널링 파일 시스템을 지원한다.
- + 저널링 파일 시스템 : 데이터를 쓰기 전에 로그부터 남기는 기술. 컴퓨터가 강제로 꺼져도 재부팅 할 때 검사 속도가 빠르다.

#### 4. 가상 메모리
- 물리적인 메모리를 극복하기 위한 메모리 관리 기법.
- 프로세스들이 접근하는 메모리를 가상 메모리에 매핑하고 가상 메모리는 페이지를 통하여 물리 메모리에 매핑한다.
- 시스템에서 동작 중인 프로세스가 사용하는 메모리만을 물리 메모리에 로드하며 사용빈도가 낮은 메모리는 디스크에 저장한다. 이를 요구 페이징(Demand Paging)이라고 한다.
- 이러한 가상 메모리는 넓은 주소 공간과 각 페이지에 대한 보호 매커니즘, 이미지와 데이터 파일을 프로세스의 주소 공간과 각 페이지에 대한 보호 매커니즘, 이미지와 데이터 파일을 프로세스의 주소 공간에 매핑하는 메모리 매핑, 프로세스 간 공유 메모리 기능을 제공한다.

가상 메모리는 여러 프로그램이 같은 주소를 사용하고자 할 경우 유용하다.
두 프로그램이 같은 주소를 사용하고자 할 때, 가상 메모리 기법을 사용하지 않는다면 충돌이 일어나 컴퓨터가 다운될 것이다. 하지만 가상 메모리 기법을 사용하면 각 프로그램에 가짜인 가상 메모리 주소를 건네주고, 그 가상 주소를 다른 물리 메모리 주소에 매핑을 시켜놓는다.

결론적으로 두 프로그램은 둘 다 같은 주소를 쓴다고 생각하지만 실제로는 다르기 때문에 침범이 불가능하다. 이를 메모리 보호라고 한다.

프로세스 작업의 극대화를 위해 실제 사용 가능한 메모리의 용량보다 더 많은 용량을 가상 메모리로 지정시키는 정책을 메모리 오버커밋이라고 한다. 

`/proc/sys/vm/overcommit_memory`에서 오버커밋 정책을 관리할 수 있다.

| **값** | **모드**              | **설명**                            | **비고**                  |
| ----- | ------------------- | --------------------------------- | ----------------------- |
| **0** | **Heuristic (눈치껏)** | "적당히 봐가면서 뻥치자." (기본값)             | 너무 심한 요구는 거절함.          |
| **1** | **Always (무조건)**    | "달라는 대로 다 줘."                     | 묻지도 따지지도 않고 OK. 위험함.    |
| **2** | **Never (엄격함)**     | "가진 만큼만 빌려줘." (Swap + RAM의 일정 비율) | 오버커밋 금지. 안정적이지만 낭비가 심함. |

#### 5. 스왑
- 물리 메모리 사용량이 가득 차서 프로그램을 메모리에 로드할 수 없는 경우, 메모리 접근 또는 실행 빈도가 낮은 데이터나 프로그램을 디스크로 옮기고 물리 메모리를 확보하여 프로그램을 메모리로 다시 로드.
- 디스크로 옮기는 동작을 스왑 아웃, 메모리로 옮기는 작업을 스왑 인이라고 한다.
- 디스크 상의 공간을 특별히 스왑 공간이라고 부르며 이를 위한 전용 파일이나 파티션이 존재해야 한다.
- 최대 절전 기능을 사용하기 위해서는 스왑 파티션이 필요하다. 메모리에 저장된 데이터는 전원 공급이 중단되면 사라지는 휘발적 특성을 가지고 있기 때문에 디스크에 데이터를 저장하는 것이 필요하다.
- 스왑 빈도를 변경하기 위해서는 /etc/sysctl.conf의 vm.swapiness를 설정한다. 만약 10으로 설정한다면 스왑 영역의 가용량이 10%일때 스왑을 시도함,
- free 명령어로 스왑 영역의 용량을 확인할 수 있다. 물론 메모리의 상태도 확인할 수 있다. 
- 물리 메모리의 한계를 극복하고 효율적으로 메모리 공간을 활용할 수 있다는 장점도 있지만, 동적으로 스왑의 크기를 조절할 수 없어 하드디스크의 공간을 차지한다는 단점도 있다.

하드디스크를 나눌 때, 스왑 파티션에게 부여하는 고유 번호가 있다.
- 82번(Linux Swap)
- 83번(Linux Native - 일반적인 exts, xfs등)

만약 램이 너무 부족해서 스왑이 빈번하게 일어날 경우, CPU는 제대로 일을 하지 못하고 정신을 못차리게 된다. 때문에 컴퓨터가 느려지게 되는데, 이 현상을 스래싱(Thrashing)이라고 한다.

여기서 스왑까지 전부 다 했는데도 프로그램이 계속해서 주소를 요구한다면, OOM Killer(Out Of Memory Killer)가 가장 메모리 점유가 높으면서 중요도가 낮은 프로세스를 골라서 강제로 죽여버린다. 이렇게 강제 종료된 프로세스는 /var/log/messages 같은 시스템 로그에 보면 "Out of memory: kill process 1234 (java)..." 이렇게 기록이 남게 된다.

#### 6. 동적 라이브러리와 정적 라이브러리
- 동적 라이브러리를 메모리에 한 번 적재하고 나면 여러 프로세스가 매번 동일한 라이브러리를 로드할 필요 없이 공용으로 라이브러리를 사용 가능.
- 정적 라이브러리는 실행 프로그램이 컴파일될 때 링크되어 프로세스가 실행될 때 정적 라이브러리도 함께 메모리로 로드된다. 동일한 정적 라이브러리를 링크한 다른 프로세스가 실행될 때, 정적 라이브러리는 중복으로 적재된다.
- 동적 라이브러리는 메모리 실행 프로그램의 크기가 작고 효율적으로 메모리 사용 가능. 하지만 실행 속도가 느리고 배포에 제약이 존재.
- 정적 라이브러리는 속도가 빠르고 배포에 제약이 없지만, 실행 파일의 크기가 상대적으로 큼.
- 로더는 환경변수 LD_LIBRARY_PATH와 환경설정 파일 /etc/ld.so.conf를 검색하여 동적 라이브러리를 로드한다. 또한 리눅스는 빠른 동적 라이브러리 경로 검색을 위해 /etc/ld.so.cache 파일을 유지하는데 ldconfig 명령을 통해 생성할 수 있다. 즉, /etc/ld.so.conf 파일 변경시 ldconfig 명령어를 통해 /etc/ld.so.cache 파일의 갱신이 필요하다.

#### 7. 파이프
- 프로세스의 표준 출력을 다른 프로세스의 표준 입력으로 보낼 수 있는 프로세스 간 통신방식. 터미널에서 사용할 수 있는 파이프 기호는 `'|'`

#### 8. 가상 콘솔
- 하나의 화면에서 여러 개의 콘솔을 사용할 수 있는 기능을 제공한다. 이 콘솔은 텍스트 기반 터미널일 수도 있고, X 윈도우 같은 그래픽 화면일 수도 있다.
- 리눅스는 총 6개의 콘솔을 제공하고 Ctrl + Alt + F1 ~ F6을 통해 콘솔을 생성할 수 있다. 특히 X 윈도우의 경우 Ctrl + Alt + F7 단축키를 사용한다.
- 콘솔 간 전환을 위해서는 Alt + 각 펑션키 (F1 ~ F6)을 눌러 빠르게 이동 가능.

### 4. 리눅스의 장단점
#### 1. 리눅스의 장점
- 오픈소스이기 때문에 운영체제 라이선스 비용이 없음. 경제적이다.
- 전 세계의 개발자들이 리눅스의 커널 소스를 수정하고 개량함으로써 운영체제를 더욱 안정적으로 개선하고 보안성을 강화중.
- 이더넷, SLIP, PPP등 다양한 네트워크 환경을 지원하며 TCP/IP, IPX 등의 네트워크 프로토콜도 지원.
- 서버, 개발용, PC용 등 다양한 목적으로 사용 가능하고 이에 따른 다양한 배포판이 존재함. 또한 원하는 제품으로 커스터마이징이 가능.

#### 2. 리눅스의 단점
- 사용자들의 이슈를 해결해 줄 수 있는 체계적인 기술지원 네트워크의 부재
- 쓸만한 리눅스용 상용 소프트웨어가 부족함
- 최신 하드웨어 기기에 대한 디바이스 지원이 느림. 제조사에서 드라이버를 만들어주지 않으면 개발자들이 리버스 엔지니어링 (역분석)을 통해 드라이버를 만들어 내야 한다.

## 2. 리눅스와 CNG 그리고 오픈 라이선스
### 1. 리눅스와 GNU(GNU's not Unix)
#### 1. GNU GPL(General Public License) 라이선스를 갖는 리눅스
- 리눅스는 유닉스에서 아이디어를 얻고 유닉스의 POSIX 표준을 따르고 있으나 유닉스의 소스코드를 일체 사용하지 않고 모두 새롭게 작성함.
- 리눅스는 GNU GPL 라이선스를 가짐. 누구나 자유롭게 사용, 변경, 배포가 가능함.
- GNU GPL에 따라 배포되는 소프트웨어들을 특히 자유 소프트웨어라고 부른다. 
- GNU GPL에 따라 리눅스를 자유롭게 복제, 개작, 배포할 수 있지만 GPL 라이선스를 갖는 코드를 가져다 쓰는 경우 해당 소프트웨어도 GPL 라이선스로 배포되어야 한다는 제약이 있다. 서로 기술 공유를 통해 자유 소프트웨어의 개발과 기술 발전을 추구하기 위한 의도.
- 리눅스 운영체제는 가격이 무료인걸 추구하는게 아니고 일반 저작권을 반대하기 위한 것도 아님. 소스코드의 자유로운 공유를 통한 기술 발전과 소프트웨어 산업 발전을 목적으로 함.

#### 2. GNU(GNU's Not Unix)
- GNU는 유닉스가 아니다. 라는 뜻을 가짐
- 소프트웨어의 상업화를 반대하고 소프트웨어를 자유롭게 사용할 수 있는 리차드 스톨만을 주축으로 자유 소프트웨어를 갈망하는 개발자들이 모여 공동체를 형성. 그 안에서 다양한 소프트웨어가 개발됨.
- GNU는 유닉스와 호환은 되지만 다른 운영체제라는 이중적 의미를 가지고 있음.
- 1983년 시작된 이래 GUN C 컴파일러 (gcc), 문서 편집기 (GNU Emacs), X 윈도우 (GNOME), 파일압축(tar), 셸(bash), 부트매니저(grub)등 다양한 분야의 응용 프로그램을 개발함.

#### 3. 자유 소프트웨어의 정의
- 자유 소프트웨어는 다음과 같은 4가지 종류의 자유를 내포함.
	- 자유0: 프로그램을 어떠한 목적을 위해서도 실행할 수 있는 자유
	- 자유1: 프로그램의 작동 원리를 연구하고 이를 자신의 필요에 맞게 변경시킬 수 있는 자유
	- 자유2: 이웃을 돕기 위해서 프로그램을 복제 및 배포할 수 있는 자유
	- 자유3: 프로그램을 향상하고 이를 공동체 전체의 이익을 위해 다시 환원할 수 있는 자유
- 소스코드 없이 자유 1과 자유 3을 지키는 것을 비현실적. 때문에 소스코드의 제공이 필요하다고 피력하고 있음.

#### 4. 카피레프트(Copyleft)
- 저작권을 뜻하는 카피라이트의 반대 의미를 가짐.
- 자유 소프트웨어를 사용자가 자유롭게 사용할 수 있도록 법률적 보장을 위해 만들어진 개념이 카피레프트.
- 카피레프트를 실제 구현한 라이선스가 GNU GPL 라이선스. 현재 수많은 자유 소프트웨어를 사용자가 자유롭게 사용할 수 있는 권리가 보장되고 있음.

### 2. 오픈소스(Open Source)
- 오픈 소스는 소프트웨어나 하드웨어의 저작자 권리를 지키며 원시 코드를 누구나 열람할 수 있도록 한 소프트웨어를 말함. 
- 1998년 2월 3일 캘리포티아 팔로 알토에서 열린 전략회의에서 넷스케이프 코드를 어떤 형태로 공개할까 논의 중 처음 사용된 용어가 오픈소스.
- 오픈소스 소프트웨어를 장려하기 위해 1998년 2월 오픈소스이니셔티브(OSI : Open Source Initiative)가 브루스 페렌스와 에릭 레이먼드에 의해 설립됨.
- 오픈소스와 자유 소프트웨어는 전체적으로 비슷한 맥락을 가지고 있음. 뭐시기 뭐시기 따분한 이야기

> **오픈소스이니셔티브에 등록되기 위한 오픈소스의 10가지 조건**
> 1. 자유 배포
> 2. 소스코드 공개
> 3. 2차적 저작물 허용
> 4. 소스코드 수정 제한
> 5. 개인이나 단체에 대한 차별 금지
> 6. 사용 분야에 대한 제한 금지
> 7. 라이선스의 배포
> 8. 라이선스 적용상의 동일성 유지
> 9. 다른 라이선스의 포괄적 수용
> 10. 라이선스의 기술적 중립성
{: .prompt-info }

### 3. 다양한 오픈소스 라이선스
#### 1. GPL 라이선스
- GPL은 v1, v2, v3 총 3개의 버전이 존재함.

>**소프트웨어에 관련된 다섯 가지 의무**
>1. 컴퓨터 프로그램을 어떠한 목적으로든 사용할 수 있다. 하지만 법으로 제한하는 행위는 불가능.
>2. 컴퓨터 프로그램의 실행 복사본은 언제나 프로그램의 소스코드와 함께 판매하거나 코드를 무료로 배포해야 함.
>3. 컴퓨터 프로그램의 소스코드를 용도에 따라 변경할 수 있다.
>4. 변경된 컴퓨터 프로그램 역시 소스코드를 반드시 공개 배포해야 함.
>5. 변경된 컴퓨터 프로그램 역시 반드시 똑같은 GPL 라이선스를 적용해야함.
{: .prompt-info }

| GPL 버전 | 발표일          | 주요 내용                                                                                                                |
| ------ | ------------ | -------------------------------------------------------------------------------------------------------------------- |
| GPLv1  | 1989년 1월     | 바이너리 형태의 프로그램을 GPLv1로 배포할 때는 사람이 이해 가능한 소스코드를 함께 배포해야 한다는 조건.<br>GPLv1 프로그램을 수정한 프로그램도 원래 프로그램과 마찬가지로 v1 라이선스를 가져야 함 |
| GPLv2  | 1991년 6월     | 특정 이유(특허 등)으로 GPL 프로그램 배포 시 소스코드 공개를 불허하려 한다면 프로그램 바이너리 공개도 하지 못하도록 라이선스를 보완                                         |
| GPLv3  | 2007년 6월 29일 | 주요 변경사항은 소프트웨어 특허에 대한 대처, 다른 라이선스와의 호환성, 원시 코드의 구성법, DRM (디지털권리관리) 관련 내용 추가                                          |

#### 2. LGPL 라이선스 (Library / Lesser General Public License)
- GNU GPL 라이선스의 강력한 카피레프트 조건과 BSD 라이선스의 사용허가나 MIT 라이선스의 단순 사용허가를 절중하여 만든 자유 소프트웨어 재단의 자유 소프트웨어 라이센스.
- 리처드 스톨만과 이벤 모글렌의 법률 자문을 받아 만들고 개정함.