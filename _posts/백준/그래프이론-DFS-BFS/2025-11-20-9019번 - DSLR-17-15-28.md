---
layout: post
title: 9019번 - DSLR
date: 2025-11-20 17:15:28 +0900
categories:
  - 백준
  - DFS/BFS
  - 역추적
published: true
math: true
tags:
  - BFS
  - 백준
  - 역추적
  - 그래프이론
---
BFS를 사용하여 가장 짧은 연산을 구하는 문제이다. 해당 코드로 제출했을 때 4초 언저리로 6초라는 긴 제한시간 안에 들긴 했지만 시간을 더 줄이려면 역추적을 사용해야 한다. 현재 코드는 반복되는 객체의 생성 (Register)과 문자열 덧셈이 있기 때문에 시간이 꽤나 오래 걸린다. 해당 코드는 나중에 작성해봐야겠다. 연산 알고리즘 자체는 간단한 수학이기 때문에 생각보다 어렵진 않았다.

```java
import java.io.*;  
import java.util.LinkedList;  
import java.util.Queue;  
import java.util.StringTokenizer;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int N = Integer.parseInt(br.readLine());  
  
        for (int i = 0; i < N; i++) {  
            StringTokenizer st = new StringTokenizer(br.readLine());  
            int A = Integer.parseInt(st.nextToken());  
            int B = Integer.parseInt(st.nextToken());  
  
            String resultOperation = solve(A, B);  
            sb.append(resultOperation).append("\n");  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
  
    static class Register {  
        int num;  
        String operation;  
  
        public Register(int num, String operation) {  
            this.num = num;  
            this.operation = operation;  
        }  
    }  
  
    static String solve(int A, int B) {  
        boolean[] visited = new boolean[10000];  
        String operation = "";  
        Queue<Register> q = new LinkedList<>();  
        q.offer(new Register(A, operation));  
  
        outer:  
        while (true) {  
            Register current = q.poll();  
  
            int temp = current.num;  
            String tempOperation = current.operation;  
            for (int i = 0; i < 4; i++) {  
                int newNum = 0;  
                String newOperation = "";  
                switch (i) {  
                    case 0:  
                        newNum = doubleNum(temp);  
                        newOperation = tempOperation + "D";  
                        break;  
                    case 1:  
                        newNum = minus(temp);  
                        newOperation = tempOperation + "S";  
                        break;  
                    case 2:  
                        newNum = leftShift(temp);  
                        newOperation = tempOperation + "L";  
                        break;  
                    case 3:  
                        newNum = rightShift(temp);  
                        newOperation = tempOperation + "R";  
                        break;  
                }  
                if (visited[newNum]) {  
                    continue;  
                } else {  
                    visited[newNum] = true;  
                }  
  
                if (newNum == B) {  
                    operation = newOperation;  
                    break outer;  
                } else {  
                    q.offer(new Register(newNum, newOperation));  
                }  
            }  
        }  
  
        return operation;  
    }  
  
    static int doubleNum(int num) {  
        return (2 * num) % 10000;  
    }  
  
    static int minus(int num) {  
        int result;  
  
        if (num == 0) {  
            result = 9999;  
        } else {  
            result = num - 1;  
        }  
  
        return result;  
    }  
  
    static int leftShift(int num) {  
        return (num % 1000) * 10 + (num / 1000);  
    }  
  
    static int rightShift(int num) {  
        return (num % 10) * 1000 + num / 10;  
    }  
}
```