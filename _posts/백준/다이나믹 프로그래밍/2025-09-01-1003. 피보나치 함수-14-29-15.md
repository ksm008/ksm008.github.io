---
layout: post
title: 1003번 - 피보나치 함수
date: 2025-09-01 14:29:15 +0900
categories:
  - 백준
  - 다이나믹 프로그래밍
published: true
tags:
  - 백준
---
```java
import java.io.*;  
import java.util.HashMap;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
    static HashMap<Integer, Integer> map = new HashMap<>();  
    public static void main(String[] args) throws IOException {  
  
        int num = Integer.parseInt(br.readLine());  
  
        for (int i = 0; i < num; i++) {  
            int cases = Integer.parseInt(br.readLine());  
            map.put(0, 0);  
            map.put(1, 0);  
  
            fibonacci(cases);  
  
            bw.write(map.get(0) + " " + map.get(1) + "\n");  
        }  
  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
  
    static int fibonacci (int n) throws IOException {  
        if (n == 0 || n == 1) {  
            map.put(n, map.get(n) + 1);  
            return n;  
        } else {  
            return fibonacci(n - 1) + fibonacci(n - 2);  
        }  
    }  
}
```

보통 피보나치 함수를 구현할 때는 재귀를 이용하여 표현하는 편이다. 하지만 재귀함수는 계속해서 함수를 호출하기 때문에 시간이 오래 걸린다는 단점이 있다. 이 단점을 해결해야 하는 문제가 바로 [1003번 - 피보나치 함수](https://www.acmicpc.net/problem/1003)이다. 문제에 써져있는 피보나치 함수를 구현하여 제출한다면 시간 초과가 뜬다.

계속해서 함수를 호출하지 않기 위해서 어떤 방법을 써야 할까? 바로 다이나믹 프로그래밍 알고리즘을 도입하는 것이다. 이전에 계산했던 결과는 그대로 저장해두고 원하는 값만 골라서 쓴다면 시간복잡도가 O(1)이 되므로 이전보다 훨신 빠르게 계산이 가능하다.


```java
import java.io.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
  
    public static void main(String[] args) throws IOException {  
        int num = Integer.parseInt(br.readLine());  
        int[] cases = new int[num];  
        int max = 0;  
  
        for (int i = 0; i < num; i++) {  
            cases[i] = Integer.parseInt(br.readLine());  
            if (cases[i] > max) {  
                max = cases[i];  
            }  
        }  
  
        int[] cnt0 = new int[max + 2];  
        int[] cnt1 = new int[max + 2];  
  
        cnt0[0] = 1; cnt1[0] = 0;  
        cnt0[1] = 0; cnt1[1] = 1;  
  
        for (int i = 2; i <= max; i++) {  
            cnt0[i] = cnt0[i - 1] + cnt0[i - 2];  
            cnt1[i] = cnt1[i - 1] + cnt1[i - 2];  
        }  
  
        StringBuilder sb = new StringBuilder();  
        for (int n : cases) {  
            sb.append(cnt0[n]).append(" ").append(cnt1[n]).append("\n");  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

0과 1의 카운트를 저장하는 배열의 크기가 최대 + 2인 이유는 입력으로 0이 들어왔을때를 생각해보면 쉽다.

만약 입력으로 0이 들어오게 되면 cnt0과 cnt1의 배열의 크기는 0 + 1이므로 1이 된다. 즉, 인덱스로는 0밖에 들어올 수 없게 된다. 근데 바로 아래 코드에서 `cnt0[1]`과 같이 없는 인덱스를 참조하고 있기 때문에 ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 에러가 뜰 것이다.

그리고 매번 bufferedWriter로 작성하는 것보다 StringBuilder로 문자열 생성 후 한번에 출력하는 것이 더 빠르기 때문에 앞으로 자주 사용하려 한다.