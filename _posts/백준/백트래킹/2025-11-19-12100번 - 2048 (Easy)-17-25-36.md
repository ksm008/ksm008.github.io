---
layout: post
title: 12100번 - 2048 (Easy)
date: 2025-11-19 17:25:36 +0900
categories:
  - 백준
  - 백트래킹
  - 브루트포스
published: true
math: true
tags:
  - 백준
  - 백트래킹
  - 브루트포스
  - 시뮬레이션
---
나중에 다시 봐야 할 코드 중 하나이다. 백트래킹을 이해하는데 가장 좋은 코드 같다. 

```java
import java.io.*;  
import java.util.ArrayList;  
import java.util.List;  
import java.util.Objects;  
import java.util.StringTokenizer;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    static int N;  
  
    public static void main(String[] args) throws IOException {  
        N = Integer.parseInt(br.readLine());  
  
        int[][] board = new int[N][N];  
  
        StringTokenizer st;  
        for (int i = 0; i < N; i++) {  
            st = new StringTokenizer(br.readLine());  
            for (int j = 0; j < N; j++) {  
                board[i][j] = Integer.parseInt(st.nextToken());  
            }  
        }  
  
        int result = solveGame(0, board);  
        sb.append(result);  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
  
    static int solveGame(int rep, int[][] board) {  
        if (rep == 5) {  
            int max = Integer.MIN_VALUE;  
            for (int i = 0; i < N; i++) {  
                for (int j = 0; j < N; j++) {  
                    if (board[i][j] > max) {  
                        max = board[i][j];  
                    }  
                }  
            }  
            return max;  
        }  
  
        int curMax = Integer.MIN_VALUE;  
  
        for (int i = 0; i < N; i++) {  
            for (int j = 0; j < N; j++) {  
                if (board[i][j] > curMax) {  
                    curMax = board[i][j];  
                }  
            }  
        }  
  
        for (int i = 0; i < 4; i++) {  
            int[][] copiedBoard = copyBoard(board);  
            move(copiedBoard, i);  
            int nextResult = solveGame(rep + 1, copiedBoard);  
  
            if (nextResult > curMax) {  
                curMax = nextResult;  
            }  
        }  
  
        return curMax;  
    }  
  
    static int[][] copyBoard(int[][] board) {  
        int[][] copiedBoard = new int[N][N];  
        for (int i = 0; i < N; i++) {  
            System.arraycopy(board[i], 0, copiedBoard[i], 0, N);  
        }  
        return copiedBoard;  
    }  
  
    static void move(int[][] copiedBoard, int direction) {  
        switch (direction) {  
            case 0: // 왼쪽으로 이동  
                for (int i = 0; i < N; i++) {  
                    copiedBoard[i] = moveLeft(copiedBoard[i]);  
                }  
                break;  
            case 1: // 오른쪽으로 이동  
                for (int i = 0; i < N; i++) {  
                    copiedBoard[i] = moveRight(copiedBoard[i]);  
                }  
                break;  
            case 2: // 위로 이동  
                for (int i = 0; i < N; i++) {  
                    int[] tempCol = new int[N];  
  
                    for (int j = 0; j < N; j++) {  
                        tempCol[j] = copiedBoard[j][i];  
                    }  
  
                    int[] result = moveLeft(tempCol);  
  
                    for (int j = 0; j < N; j++) {  
                        copiedBoard[j][i] = result[j];  
                    }  
                }  
                break;  
            case 3: // 아래로 이동  
                for (int i = 0; i < N; i++) {  
                    int[] tempCol = new int[N];  
  
                    for (int j = 0; j < N; j++) {  
                        tempCol[j] = copiedBoard[j][i];  
                    }  
  
                    int[] result = moveRight(tempCol);  
  
                    for (int j = 0; j < N; j++) {  
                        copiedBoard[j][i] = result[j];  
                    }  
                }  
                break;  
  
        }  
    }  
  
    static int[] moveLeft(int[] row) {  
        int[] temp = new int[N];  
        List<Integer> zeroExcluded = new ArrayList<>();  
        List<Integer> result = new ArrayList<>();  
  
        for (int i = 0; i < N; i++) {  
            if (row[i] != 0) {  
                zeroExcluded.add(row[i]);  
            }  
        }  
  
        for (Integer num : zeroExcluded) {  
            int idx = result.size() - 1;  
            if (result.isEmpty()) result.add(num);  
            else {  
                int curNum = result.get(idx);  
                if (Objects.equals(result.get(idx), num)) {  
                    result.set(idx, (num + curNum) * -1);  
                } else {  
                    result.add(num);  
                }  
            }  
        }  
  
  
        for (int i = 0; i < result.size(); i++) {  
            int curNum = result.get(i);  
            if (curNum < 0) curNum *= -1;  
            temp[i] = curNum;  
        }  
  
        return temp;  
    }  
  
    static int[] moveRight(int[] row) {  
        int[] temp = new int[N];  
        List<Integer> zeroExcluded = new ArrayList<>();  
        List<Integer> result = new ArrayList<>();  
  
        for (int i = N - 1; i >= 0; i--) {  
            if (row[i] != 0) {  
                zeroExcluded.add(row[i]);  
            }  
        }  
  
        for (Integer num : zeroExcluded) {  
            int idx = result.size() - 1;  
            if (result.isEmpty()) result.add(num);  
            else {  
                int curNum = result.get(idx);  
                if (Objects.equals(result.get(idx), num)) {  
                    result.set(idx, (num + curNum) * -1);  
                } else {  
                    result.add(num);  
                }  
            }  
        }  
  
        if (result.size() < N) {  
            for (int i = 0; i < N - result.size(); i++) {  
                result.add(0);  
            }  
        }  
  
        int tempIdx = N - 1;  
  
        for (int i = 0; i < result.size(); i++) {  
            int curNum = result.get(i);  
            if (curNum < 0) curNum *= -1;  
            temp[tempIdx--] = curNum;  
        }  
  
        return temp;  
    }  
}
```