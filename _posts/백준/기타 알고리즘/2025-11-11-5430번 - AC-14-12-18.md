---
layout: post
title: 5430번 - AC
date: 2025-11-11 14:12:18 +0900
categories:
  - 백준
  - 기타 알고리즘
published: true
math: true
tags:
  - 백준
  - 문자열
  - 덱
---
문자열을 계속해서 뒤집고 삭제하는건 시간 낭비이다. 때문에 플래그를 알려주는 불린 값을 하나 사용하고, 앞 뒤 양쪽으로 삭제가 가능한 덱을 사용하면 된다.
에러가 발생하는 때는 숫자가 없을 때 삭제 연산을 할 때이다. 만약 덱이 비어있는데 삭제 연산을 하게 될 경우, 이 때만 에러를 출력해주면 된다. 

```java
import java.io.*;  
import java.util.ArrayDeque;  
import java.util.Deque;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int T = Integer.parseInt(br.readLine());  
  
        outer:  
        for (int i = 0; i < T; i++) {  
            String operation = br.readLine();  
            int arrayLen = Integer.parseInt(br.readLine());  
            String array = br.readLine();  
            array = array.substring(1, array.length() - 1).replaceAll(",", " ");  
            String[] strArray = array.split(" ");  
  
            Deque<Integer> deque;  
  
            if (arrayLen == 0) {  
                deque = new ArrayDeque<>();  
            } else {  
                deque = new ArrayDeque<>();  
  
                for (String str : strArray) {  
                    deque.add(Integer.parseInt(str));  
                }  
            }  
  
            boolean isReversed = false;  
  
            for (int j = 0; j < operation.length(); j++) {  
                char ch = operation.charAt(j);  
  
                if (ch == 'R') {  
                    isReversed = !isReversed;  
                } else {  
                    if (deque.isEmpty()) {  
                        sb.append("error" + "\n");  
                        continue outer;  
                    }  
                    if (isReversed) {  
                        deque.pollLast();  
                    } else {  
                        deque.pollFirst();  
                    }  
                }  
            }  
  
            sb.append("[");  
            int size = deque.size();  
            if (!isReversed) {  
                for (int j = 0; j < size; j++) {  
                    if (j != size - 1) {  
                        sb.append(deque.pollFirst()).append(",");  
                    } else {  
                        sb.append(deque.pollFirst());  
                    }  
                }  
            } else {  
                for (int j = size - 1; j >= 0; j--) {  
                    if (j != 0) {  
                        sb.append(deque.pollLast()).append(",");  
                    } else {  
                        sb.append(deque.pollLast());  
                    }  
                }  
            }  
            sb.append("]\n");  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```