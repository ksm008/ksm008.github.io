---
layout: post
title: 5525번 - IOIOI
date: 2025-11-03 17:38:59 +0900
categories:
  - 백준
  - 기타 알고리즘
published: true
math: true
tags:
  - 백준
  - 문자열
---
처음에는 시간 제약에 상관없는 코드를 짜봤다. 누가봐도 타임아웃이 분명해보이는 코드였지만 TestCase에는 변수의 범위가 터무니없이 좁아 아무런 도움이 되지 못했다.

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int N = Integer.parseInt(br.readLine());  
        int S = Integer.parseInt(br.readLine());  
        String str = br.readLine();  
  
        int rotateStringLen = 2 * N + 1;  
        int count = 0;  
  
        for (int i = 0; i < S - rotateStringLen + 1; i++) {  
            char cur = str.charAt(i);  
            if (cur == 'I') {  
                boolean isTrue = true;  
                for (int j = 0; j < rotateStringLen; j++) {  
                    int checkChar = str.charAt(i + j);  
  
                    if (j % 2 == 0) {  
                        if (checkChar != 'I') {  
                            isTrue = false;  
                            break;  
                        }  
                    } else {  
                        if (checkChar != 'O') {  
                            isTrue = false;  
                            break;  
                        }  
                    }  
                }  
                if (isTrue) {  
                    count++;  
                }  
            }  
        }  
        sb.append(count);  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

문자를 하나씩 확인하며 중간에 for문이 다시 돌아가게 되므로 무조건 시간이 더 오래걸려 타임아웃이 뻔했다. 그래서 아예 딱 1번만 문자열을 훑으며 찾아낼 수 있는 방법을 생각해내야 했다.

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int N = Integer.parseInt(br.readLine());  
        int S = Integer.parseInt(br.readLine());  
        String str = br.readLine();  
  
        int patternCnt = 0;  
        int totalCnt = 0;  
  
        // 시간을 최소화 하려면 단 한번만 문자열을 훑어야 한다.  
        for (int i = 0; i < S - 2; i++) {  
            if (str.charAt(i) == 'I' && str.charAt(i + 1) == 'O' && str.charAt(i + 2) == 'I') {  
                patternCnt++;  
                i++;  
                if (patternCnt >= N) {  
                    totalCnt++;  
                }  
            } else {  
                patternCnt = 0;  
            }  
        }  
  
        sb.append(totalCnt);  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

반복문은 1번만 돌아가게 되므로 훨신 코드가 간결해진다. IOI라는 패턴을 사용해서 이 패턴을 만족하게 된다면 패턴카운트를 1 늘린다. 이 패턴카운트가 N 이상이 될 경우 총카운트를 늘려 몇개가 포함되어 있는지 세주면 된다.
