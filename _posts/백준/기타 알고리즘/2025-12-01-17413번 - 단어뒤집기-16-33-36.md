---
layout: post
title: 17413번 - 단어뒤집기
date: 2025-12-01 16:33:36 +0900
categories:
  - 백준
  - 기타 알고리즘
published: true
math: true
tags:
  - 백준
  - 자료구조
  - 스택
---
태그임을 알리는 플래그 하나와 덱을 사용하여 구현을 했다. 자바에서 스택을 사용하고 싶다면 Stack 클래스 말고 ArrayDeque를 사용하는게 좋다. 

## 자바 Stack의 문제점

자바의 Stack 클래스는 원조 클래스 중 하나인 Vector 클래스를 상속받는다. 하지만 Vector 클래스의 대부분 메소드는 동기화를 담당하는 synchronized 키워드


1. 동기화를 달고 있음
	- 멀티 스레드 환경, 즉 여러 명이 동시에 작업하는 환경에서 데이터가 꼬이지 않도록 막아주는 synchronized 키워드가 모든 메소드 앞에 붙어있다. 하지만 코딩 테스트는 싱글 스레드 환경이기 때문에 불필요하다. 반면 ArrayDeque는 동기화 처리가 되어있지 않기 때문에 기본 동작 자체가 더 가볍다.
2. 상속받는 클래스
	- 스택은 Vector 클래스를 상속받는다. 이 Vector 클래스는 무거운 구형 방식이다. 이 벡터 클래스에 동기화가 거의 전부 발라져있기 때문에 스택이 영향을 받게 된다. 하지만 ArrayDeque는 이름에서 알 수 있듯 배열을 사용하기 때문에 접근 속도가 훨신 빠르다.

참고로 스택의 기능은 스트링빌더 클래스도 똑같이 가능하다. 스트링빌더에는 reverse 메소드가 있기 때문에 빌더 안에 있는 문자열을 뒤집은 후 붙인 뒤, 길이를 0으로 만들어 초기화 하게 되면 스택의 기능과 같아진다. 

```java
import java.io.*;  
import java.util.ArrayDeque;  
import java.util.Deque;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        String str = br.readLine();  
  
        Deque<Character> stack = new ArrayDeque<>();  
        boolean isTag = false;  
  
        for (int i = 0; i < str.length(); i++) {  
            char ch = str.charAt(i);  
  
            if (ch == '<') {  
                while (!stack.isEmpty()) {  
                    sb.append(stack.pop());  
                }  
                isTag = true;  
                sb.append(ch);  
            } else if (ch == '>') {  
                isTag = false;  
                sb.append(ch);  
            } else if (isTag) {  
                sb.append(ch);  
            } else if (ch == ' ') {  
                while (!stack.isEmpty()) {  
                    sb.append(stack.pop());  
                }  
                sb.append(ch);  
            } else {  
                stack.push(ch);  
            }  
        }  
        while (!stack.isEmpty()) {  
            sb.append(stack.pop());  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```