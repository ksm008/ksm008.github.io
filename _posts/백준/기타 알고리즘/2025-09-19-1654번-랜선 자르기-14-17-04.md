---
layout: post
title: 1654번 - 랜선 자르기
date: 2025-09-19 14:17:04 +0900
categories:
  - 백준
  - 기타 알고리즘
published: true
math: true
tags:
  - 이분탐색
  - 매개변수탐색
---
이 문제는 정답을 이분 탐색으로 찾아나가는 매개변수 탐색 기법을 사용한다. 랜선의 최대 길이인 L을 구하기 위해, 한 가지 질문으로 생각해보자.

"만약 랜선을 X cm로 자른다면 N개 이상 만들 수 있는가?" 에 대한 질문에 대해 답을 true, false로 바꾸어 생각하는 것이다. 

만약 X개를 잘랐을 때 N개 이상 만들 수 있다면 길이를 더 늘릴 수 있는지 확인해봐야 할 것이고, N개 미만이라면 길이를 더 줄여야 할 것이다. 이 과정에서 범위를 절반씩 줄여가는 것이 이분 탐색의 원리.

1. 우선 범위를 설정한다. 범위는 최소값인 1부터 최대값인 가장 길이가 긴 랜선 길이가 될 것이다. 예제로 생각하면 1에서 802가 될 것. 
2. 그 범위의 중간 값으로 랜선을 잘랐을 때, 다른 랜선들로 몇 개의 랜선을 만들 수 있는지 확인한다. 주어진 값보다 적으면 범위를 최대값을 중간값 - 1로 변경한다. 또는 주어긴 값보다 많거나 같다면 최소값을 중간값 - 1로 변경한다. 이 과정을 최소와 최대값이 같아질때까지 반복하면 된다.

```java
import java.io.*;  
import java.util.Arrays;  
import java.util.StringTokenizer;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int K = Integer.parseInt(st.nextToken());  
        int N = Integer.parseInt(st.nextToken());  
  
        int[] lanCable = new int[K];  
        long result = 0;  
  
        for (int i = 0; i < K; i++) {  
            lanCable[i] = Integer.parseInt(br.readLine());  
        }  
  
        Arrays.sort(lanCable);  
  
        long min = 1;  
        long max = lanCable[K - 1];  
  
        while (min <= max) {  
            long mid = (min + max) / 2;  
            long count = 0;  
  
            for (int i = 0; i < K; i++) {  
                count += lanCable[i] / mid;  
            }  
            if (count >= N) {  
                result = mid;  
                min = mid + 1;  
            } else if (count < N) {  
                max = mid - 1;  
            }  
        }  
  
        sb.append(result);  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

오랜만의 이해하기 쉽고 어렵지 않은 알고리즘 문제였다. 쉬운 문제만 풀면 안되는데 말이다...