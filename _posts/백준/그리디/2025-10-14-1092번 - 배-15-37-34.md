---
layout: post
title: 1092번 - 배
date: 2025-10-14 15:37:34 +0900
categories:
  - 백준
  - 그리디
published: true
math: true
tags:
  - 백준
  - 그리디
---
최대로 걸리는 시간은 박스의 개수와 동일하다. 만약 시간이 박스의 개수를 넘어간다면 옮길 수 없다. 즉, 가장 무거운 박스가 가장 무게 제한이 높은 크레인보다 무겁다면 옮길 수 없다. 

처음에는 크레인이 상자를 옮기면 리스트에서 상자를 한개씩 없앴는데, 리스트에서 삭제를 반복할 때마다 시간이 너무 오래 걸렸다. 그래서 그냥 불린배열을 하나 만들어서 체크를 하니 시간이 200ms 아래로 단축되었다. 언제나 리스트에서 삭제하는 작업은 시간을 잡아먹는다.

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        int N = Integer.parseInt(br.readLine());  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        Integer[] crane = new Integer[N];  
  
        for (int i = 0; i < N; i++) {  
            crane[i] = Integer.parseInt(st.nextToken());  
        }  
  
        int M = Integer.parseInt(br.readLine());  
        Integer[] boxes = new Integer[M];  
  
        st = new StringTokenizer(br.readLine());  
  
        for (int i = 0; i < M; i++) {  
            boxes[i] = Integer.parseInt(st.nextToken());  
        }  
  
        Arrays.sort(crane, Collections.reverseOrder());  
        Arrays.sort(boxes, Collections.reverseOrder());  
  
        int strongestCrain = crane[0];  
        int heaviestBox = boxes[0];  
  
        if (heaviestBox > strongestCrain) {  
            sb.append("-1");  
        } else {  
            boolean[] checked = new boolean[M];  
            int[] pos = new int[N];  
            int moved = 0;  
            int minute = 0;  
  
            while (moved < M) {  
                for (int i = 0; i < N; i++) {  
                    while (pos[i] < M) {  
                        if (!checked[pos[i]] && crane[i] >= boxes[pos[i]]) {  
                            checked[pos[i]] = true;  
                            pos[i]++;  
                            moved++;  
                            break;  
                        } else {  
                            pos[i]++;  
                        }  
                    }  
                }  
                minute++;  
            }  
            sb.append(minute);  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```