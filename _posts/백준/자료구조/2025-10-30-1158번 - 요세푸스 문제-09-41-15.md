---
layout: post
title: 1158번 - 요세푸스 문제
date: 2025-10-30 09:41:15 +0900
categories:
  - 백준
  - 자료구조
published: true
math: true
tags:
  - 백준
  - 큐
  - 자료구조
---
클래스 2 문제인 [11866번 - 요세푸스 문제 0](https://www.acmicpc.net/problem/11866)과 동일한 문제이다. 알고리즘은 아래와 같다.

1. 1부터 N을 큐에 삽입한다.
2. while문으로 큐가 빌 때까지 반복을 실행하고, 큐의 처음부터 K-1번째의 숫자를 큐에서 빼낸 후 다시 뒤로 보낸다. (예제에서 K는 3이였으니 K-1 = 2가 되므로 첫번째와 두번째 숫자를 빼낸 후 다시 뒤로 보낸다)
3. K번째 숫자는 큐에서 빼내며 출력한다. 이 과정을 반복하며 만약 큐의 크기가 1이라면 한 번만 빼내면 끝이므로 괄호를 닫도록 출력하고 아니라면 쉼표와 같이 출력한다.

```java
import java.io.*;  
import java.util.LinkedList;  
import java.util.Queue;  
import java.util.StringTokenizer;  
  
public class Main {  
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
    static StringBuilder sb = new StringBuilder();  
  
    public static void main(String[] args) throws IOException {  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken());  
        int K = Integer.parseInt(st.nextToken());  
  
        Queue<Integer> q = new LinkedList<>();  
  
        for (int i = 1; i <= N; i++) {  
            q.offer(i);  
        }  
  
        sb.append("<");  
        while (!q.isEmpty()) {  
            for (int i = 0; i < K - 1; i++) {  
                q.offer(q.poll());  
            }  
  
            if (q.size() == 1) {  
                sb.append(q.poll()).append(">");  
            } else {  
                sb.append(q.poll()).append(", ");  
            }  
        }  
  
        bw.write(sb.toString());  
        bw.flush();  
        bw.close();  
        br.close();  
    }  
}
```

알고리즘 설명은 그냥 두루뭉실하게 해두었다. 어려운 코드가 아니기 때문에 코드만 봐도 이해가 쉬울 것.