---
layout: post
title: 14503번 - 로봇 청소기
date: 2025-11-18 16:01:31 +0900
categories:
  - 백준
  - 시뮬레이션
published: true
math: true
tags:
  - 백준
  - 시뮬레이션
---
작동 순서만 똑같이 구현하면 맞는 시뮬레이션 문제이다. 주변 네 방향을 탐색하며 갈 수 없는 곳일때마다 stuckCnt를 올려주었고, stuckCnt가 4가 될 경우 후진을진행하도록 했다.

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    static StringBuilder sb = new StringBuilder();

    static int[][] room;
    static boolean[][] visited;

    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        room = new int[N][M];
        visited = new boolean[N][M];

        st = new StringTokenizer(br.readLine());

        int robotRow = Integer.parseInt(st.nextToken());
        int robotCol = Integer.parseInt(st.nextToken());
        int robotDirection = Integer.parseInt(st.nextToken());


        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                room[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        int result = hahaCleanerGoesBrr(robotRow, robotCol, robotDirection);
        sb.append(result);
        bw.write(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }

    static int hahaCleanerGoesBrr(int r, int c, int direction) {
        // 방향 인덱스에 따라 진행 방향이 달라지도록 설정. 반바퀴 회전은 방향 인덱스에 -- 해주기.
        int[] dr = {-1, 0, 1, 0}; // 세로축 (열) 이동
        int[] dc = {0, 1, 0, -1}; // 가로축 (행) 이동

        int cleanCnt = 0;

        while (true) {
            if (room[r][c] == 0) {
                if (!visited[r][c]) {
                    visited[r][c] = true;
                    cleanCnt++;
                }
            }
            int stuckCnt = 0;
            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (room[nr][nc] == 1 || visited[nr][nc]) {
                    stuckCnt++;
                }
            }
            
            if (stuckCnt == 4) {
                int nr = r - dr[direction];
                int nc = c - dc[direction];
                if (room[nr][nc] == 1) {
                    break;
                } else {
                    r = nr;
                    c = nc;
                }
            } else {
                direction--;
                if (direction < 0) direction += 4;
                int nr = r + dr[direction];
                int nc = c + dc[direction];
                if (room[nr][nc] == 0 && !visited[nr][nc]) {
                    r = nr;
                    c = nc;
                }
            }
        }

        return cleanCnt;
    }
}
```